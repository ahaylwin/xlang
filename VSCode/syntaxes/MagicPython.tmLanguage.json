#
# Copyright (C) 2024 The XLang Foundation
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# <END>

{
  "information_for_contributors": [
    "This file has been converted from https://github.com/MagicStack/MagicPython/blob/master/grammars/MagicPython.tmLanguage",
    "If you want to provide a fix or improvement, please create a pull request against the original repository.",
    "Once accepted there, we are happy to receive an update request."
  ],
  "version": "https://github.com/MagicStack/MagicPython/commit/b2b4f4ae7b4e6284e80bda8080106b93bd588f9e",
  "name": "MagicPython",
  "scopeName": "source.x",
  "patterns": [
    {
      "include": "#statement"
    },
    {
      "include": "#expression"
    }
  ],
  "repository": {
    "impossible": {
      "comment": "This is a special rule that should be used where no match is desired. It is not a good idea to match something like '1{0}' because in some cases that can result in infinite loops in token generation. So the rule instead matches and impossible expression to allow a match to fail and move to the next token.",
      "match": "$.^"
    },
    "statement": {
      "patterns": [
        {
          "include": "#import"
        },
        {
          "include": "#class-declaration"
        },
        {
          "include": "#function-declaration"
        },
        {
          "include": "#generator"
        },
        {
          "include": "#statement-keyword"
        },
        {
          "include": "#assignment-operator"
        },
        {
          "include": "#decorator"
        },
        {
          "include": "#docstring-statement"
        },
        {
          "include": "#semicolon"
        }
      ]
    },
    "semicolon": {
      "patterns": [
        {
          "name": "invalid.deprecated.semicolon.x",
          "match": "\\;$"
        }
      ]
    },
    "comments": {
      "patterns": [
        {
          "name": "comment.line.number-sign.x",
          "contentName": "meta.typehint.comment.x",
          "begin": "(?x)\n  (?:\n    \\# \\s* (type:)\n    \\s*+ (?# we want `\\s*+` which is possessive quantifier since\n             we do not actually want to backtrack when matching\n             whitespace here)\n    (?! $ | \\#)\n  )\n",
          "end": "(?:$|(?=\\#))",
          "beginCaptures": {
            "0": {
              "name": "meta.typehint.comment.x"
            },
            "1": {
              "name": "comment.typehint.directive.notation.x"
            }
          },
          "patterns": [
            {
              "name": "comment.typehint.ignore.notation.x",
              "match": "(?x)\n  \\G ignore\n  (?= \\s* (?: $ | \\#))\n"
            },
            {
              "name": "comment.typehint.type.notation.x",
              "match": "(?x)\n  (?<!\\.)\\b(\n    bool | bytes | float | int | object | str\n    | List | Dict | Iterable | Sequence | Set\n    | FrozenSet | Callable | Union | Tuple\n    | Any | None\n  )\\b\n"
            },
            {
              "name": "comment.typehint.punctuation.notation.x",
              "match": "([\\[\\]\\(\\),\\.\\=\\*]|(->))"
            },
            {
              "name": "comment.typehint.variable.notation.x",
              "match": "([[:alpha:]_]\\w*)"
            }
          ]
        },
        {
          "include": "#comments-base"
        }
      ]
    },
    "docstring-statement": {
      "begin": "^(?=\\s*[rR]?(\\'\\'\\'|\\\"\\\"\\\"|\\'|\\\"))",
      "comment": "the string either terminates correctly or by the beginning of a new line (this is for single line docstrings that aren't terminated) AND it's not followed by another docstring",
      "end": "((?<=\\1)|^)(?!\\s*[rR]?(\\'\\'\\'|\\\"\\\"\\\"|\\'|\\\"))",
      "patterns": [
        {
          "include": "#docstring"
        }
      ]
    },
    "docstring": {
      "patterns": [
        {
          "name": "string.quoted.docstring.multi.x",
          "begin": "(\\'\\'\\'|\\\"\\\"\\\")",
          "end": "(\\1)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.definition.string.begin.x"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.definition.string.end.x"
            }
          },
          "patterns": [
            {
              "include": "#docstring-prompt"
            },
            {
              "include": "#codetags"
            },
            {
              "include": "#docstring-guts-unicode"
            }
          ]
        },
        {
          "name": "string.quoted.docstring.raw.multi.x",
          "begin": "([rR])(\\'\\'\\'|\\\"\\\"\\\")",
          "end": "(\\2)",
          "beginCaptures": {
            "1": {
              "name": "storage.type.string.x"
            },
            "2": {
              "name": "punctuation.definition.string.begin.x"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.definition.string.end.x"
            }
          },
          "patterns": [
            {
              "include": "#string-consume-escape"
            },
            {
              "include": "#docstring-prompt"
            },
            {
              "include": "#codetags"
            }
          ]
        },
        {
          "name": "string.quoted.docstring.single.x",
          "begin": "(\\'|\\\")",
          "end": "(\\1)|(\\n)",
          "beginCaptures": {
            "1": {
              "name": "punctuation.definition.string.begin.x"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.definition.string.end.x"
            },
            "2": {
              "name": "invalid.illegal.newline.x"
            }
          },
          "patterns": [
            {
              "include": "#codetags"
            },
            {
              "include": "#docstring-guts-unicode"
            }
          ]
        },
        {
          "name": "string.quoted.docstring.raw.single.x",
          "begin": "([rR])(\\'|\\\")",
          "end": "(\\2)|(\\n)",
          "beginCaptures": {
            "1": {
              "name": "storage.type.string.x"
            },
            "2": {
              "name": "punctuation.definition.string.begin.x"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.definition.string.end.x"
            },
            "2": {
              "name": "invalid.illegal.newline.x"
            }
          },
          "patterns": [
            {
              "include": "#string-consume-escape"
            },
            {
              "include": "#codetags"
            }
          ]
        }
      ]
    },
    "docstring-guts-unicode": {
      "patterns": [
        {
          "include": "#escape-sequence-unicode"
        },
        {
          "include": "#escape-sequence"
        },
        {
          "include": "#string-line-continuation"
        }
      ]
    },
    "docstring-prompt": {
      "match": "(?x)\n  (?:\n    (?:^|\\G) \\s* (?# '\\G' is necessary for ST)\n    ((?:>>>|\\.\\.\\.) \\s) (?=\\s*\\S)\n  )\n",
      "captures": {
        "1": {
          "name": "keyword.control.flow.x"
        }
      }
    },
    "statement-keyword": {
      "patterns": [
        {
          "name": "storage.type.function.x",
          "match": "\\b((async\\s+)?\\s*def)\\b"
        },
        {
          "name": "keyword.control.flow.x",
          "comment": "if `as` is eventually followed by `:` or line continuation\nit's probably control flow like:\n    with foo as bar, \\\n         Foo as Bar:\n      try:\n        do_stuff()\n      except Exception as e:\n        pass\n",
          "match": "\\b(?<!\\.)as\\b(?=.*[:\\\\])"
        },
        {
          "name": "keyword.control.import.x",
          "comment": "other legal use of `as` is in an import",
          "match": "\\b(?<!\\.)as\\b"
        },
        {
          "name": "keyword.control.flow.x",
          "match": "(?x)\n  \\b(?<!\\.)(\n    async | continue | del | assert | break | finally | for\n    | from | elif | else | if | except | pass | raise\n    | return | try | while | with\n  )\\b\n"
        },
        {
          "name": "storage.modifier.declaration.x",
          "match": "(?x)\n  \\b(?<!\\.)(\n    global | nonlocal\n  )\\b\n"
        },
        {
          "name": "storage.type.class.x",
          "match": "\\b(?<!\\.)(class)\\b"
        }
      ]
    },
    "expression-bare": {
      "comment": "valid Python expressions w/o comments and line continuation",
      "patterns": [
        {
          "include": "#backticks"
        },
        {
          "include": "#illegal-anno"
        },
        {
          "include": "#literal"
        },
        {
          "include": "#regexp"
        },
        {
          "include": "#string"
        },
        {
          "include": "#lambda"
        },
        {
          "include": "#generator"
        },
        {
          "include": "#illegal-operator"
        },
        {
          "include": "#operator"
        },
        {
          "include": "#curly-braces"
        },
        {
          "include": "#item-access"
        },
        {
          "include": "#list"
        },
        {
          "include": "#odd-function-call"
        },
        {
          "include": "#round-braces"
        },
        {
          "include": "#function-call"
        },
        {
          "include": "#builtin-functions"
        },
        {
          "include": "#builtin-types"
        },
        {
          "include": "#builtin-exceptions"
        },
        {
          "include": "#magic-names"
        },
        {
          "include": "#special-names"
        },
        {
          "include": "#illegal-names"
        },
        {
          "include": "#special-variables"
        },
        {
          "include": "#ellipsis"
        },
        {
          "include": "#punctuation"
        },
        {
          "include": "#line-continuation"
        }
      ]
    },
    "expression-base": {
      "comment": "valid Python expressions with comments and line continuation",
      "patterns": [
        {
          "include": "#comments"
        },
        {
          "include": "#expression-bare"
        },
        {
          "include": "#line-continuation"
        }
      ]
    },
    "expression": {
      "comment": "All valid Python expressions",
      "patterns": [
        {
          "include": "#expression-base"
        },
        {
          "include": "#member-access"
        },
        {
          "comment": "Tokenize identifiers to help linters",
          "match": "(?x) \\b ([[:alpha:]_]\\w*) \\b"
        }
      ]
    },
    "member-access": {
      "name": "meta.member.access.x",
      "begin": "(\\.)\\s*(?!\\.)",
      "end": "(?x)\n  # stop when you've just read non-whitespace followed by non-word\n  # i.e. when finished reading an identifier or function call\n  (?<=\\S)(?=\\W) |\n  # stop when seeing the start of something that's not a word,\n  # i.e. when seeing a non-identifier\n  (^|(?<=\\s))(?=[^\\\\\\w\\s]) |\n  $\n",
      "beginCaptures": {
        "1": {
          "name": "punctuation.separator.period.x"
        }
      },
      "patterns": [
        {
          "include": "#function-call"
        },
        {
          "include": "#member-access-base"
        },
        {
          "include": "#member-access-attribute"
        }
      ]
    },
    "member-access-base": {
      "patterns": [
        {
          "include": "#magic-names"
        },
        {
          "include": "#illegal-names"
        },
        {
          "include": "#illegal-object-name"
        },
        {
          "include": "#special-names"
        },
        {
          "include": "#line-continuation"
        },
        {
          "include": "#item-access"
        }
      ]
    },
    "member-access-attribute": {
      "comment": "Highlight attribute access in otherwise non-specialized cases.",
      "name": "meta.attribute.x",
      "match": "(?x)\n  \\b ([[:alpha:]_]\\w*) \\b\n"
    },
    "special-names": {
      "name": "constant.other.caps.x",
      "match": "(?x)\n  \\b\n    # we want to see \"enough\", meaning 2 or more upper-case\n    # letters in the beginning of the constant\n    #\n    # for more details refer to:\n    #   https://github.com/MagicStack/MagicPython/issues/42\n    (\n      _* [[:upper:]] [_\\d]* [[:upper:]]\n    )\n    [[:upper:]\\d]* (_\\w*)?\n  \\b\n"
    },
    "curly-braces": {
      "begin": "\\{",
      "end": "\\}",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.dict.begin.x"
        }
      },
      "endCaptures": {
        "0": {
          "name": "punctuation.definition.dict.end.x"
        }
      },
      "patterns": [
        {
          "name": "punctuation.separator.dict.x",
          "match": ":"
        },
        {
          "include": "#expression"
        }
      ]
    },
    "list": {
      "begin": "\\[",
      "end": "\\]",
      "beginCaptures": {
        "0": {
          "name": "punctuation.definition.list.begin.x"
        }
      },
      "endCaptures": {
        "0": {
          "name": "punctuation.definition.list.end.x"
        }
      },
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "odd-function-call": {
      "comment": "A bit obscured function call where there may have been an\narbitrary number of other operations to get the function.\nE.g. \"arr[idx](args)\"\n",
      "begin": "(?x)\n  (?<= \\] | \\) ) \\s*\n  (?=\\()\n",
      "end": "(\\))",
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.arguments.end.x"
        }
      },
      "patterns": [
        {
          "include": "#function-arguments"
        }
      ]
    },
    "round-braces": {
      "begin": "\\(",
      "end": "\\)",
      "beginCaptures": {
        "0": {
          "name": "punctuation.parenthesis.begin.x"
        }
      },
      "endCaptures": {
        "0": {
          "name": "punctuation.parenthesis.end.x"
        }
      },
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "line-continuation": {
      "patterns": [
        {
          "match": "(\\\\)\\s*(\\S.*$\\n?)",
          "captures": {
            "1": {
              "name": "punctuation.separator.continuation.line.x"
            },
            "2": {
              "name": "invalid.illegal.line.continuation.x"
            }
          }
        },
        {
          "begin": "(\\\\)\\s*$\\n?",
          "end": "(?x)\n  (?=^\\s*$)\n  |\n  (?! (\\s* [rR]? (\\'\\'\\'|\\\"\\\"\\\"|\\'|\\\"))\n      |\n      (\\G $)  (?# '\\G' is necessary for ST)\n  )\n",
          "beginCaptures": {
            "1": {
              "name": "punctuation.separator.continuation.line.x"
            }
          },
          "patterns": [
            {
              "include": "#regexp"
            },
            {
              "include": "#string"
            }
          ]
        }
      ]
    },
    "assignment-operator": {
      "name": "keyword.operator.assignment.x",
      "match": "(?x)\n     <<= | >>= | //= | \\*\\*=\n    | \\+= | -= | /= | @=\n    | \\*= | %= | ~= | \\^= | &= | \\|=\n    | =(?!=)\n"
    },
    "operator": {
      "match": "(?x)\n    \\b(?<!\\.)\n      (?:\n        (and | or | not | in | is)                         (?# 1)\n        |\n        (for | if | else | await | (?:yield(?:\\s+from)?))  (?# 2)\n      )\n    (?!\\s*:)\\b\n\n    | (<< | >> | & | \\| | \\^ | ~)                          (?# 3)\n\n    | (\\*\\* | \\* | \\+ | - | % | // | / | @)                (?# 4)\n\n    | (!= | == | >= | <= | < | >)                          (?# 5)\n",
      "captures": {
        "1": {
          "name": "keyword.operator.logical.x"
        },
        "2": {
          "name": "keyword.control.flow.x"
        },
        "3": {
          "name": "keyword.operator.bitwise.x"
        },
        "4": {
          "name": "keyword.operator.arithmetic.x"
        },
        "5": {
          "name": "keyword.operator.comparison.x"
        }
      }
    },
    "punctuation": {
      "patterns": [
        {
          "name": "punctuation.separator.colon.x",
          "match": ":"
        },
        {
          "name": "punctuation.separator.element.x",
          "match": ","
        }
      ]
    },
    "literal": {
      "patterns": [
        {
          "name": "constant.language.x",
          "match": "\\b(True|False|None|NotImplemented|Ellipsis)\\b"
        },
        {
          "include": "#number"
        }
      ]
    },
    "number": {
      "name": "constant.numeric.x",
      "patterns": [
        {
          "include": "#number-float"
        },
        {
          "include": "#number-dec"
        },
        {
          "include": "#number-hex"
        },
        {
          "include": "#number-oct"
        },
        {
          "include": "#number-bin"
        },
        {
          "include": "#number-long"
        },
        {
          "name": "invalid.illegal.name.x",
          "match": "\\b[0-9]+\\w+"
        }
      ]
    },
    "number-float": {
      "name": "constant.numeric.float.x",
      "match": "(?x)\n  (?<! \\w)(?:\n    (?:\n      \\.[0-9](?: _?[0-9] )*\n      |\n      [0-9](?: _?[0-9] )* \\. [0-9](?: _?[0-9] )*\n      |\n      [0-9](?: _?[0-9] )* \\.\n    ) (?: [eE][+-]?[0-9](?: _?[0-9] )* )?\n    |\n    [0-9](?: _?[0-9] )* (?: [eE][+-]?[0-9](?: _?[0-9] )* )\n  )([jJ])?\\b\n",
      "captures": {
        "1": {
          "name": "storage.type.imaginary.number.x"
        }
      }
    },
    "number-dec": {
      "name": "constant.numeric.dec.x",
      "match": "(?x)\n  (?<![\\w\\.])(?:\n      [1-9](?: _?[0-9] )*\n      |\n      0+\n      |\n      [0-9](?: _?[0-9] )* ([jJ])\n      |\n      0 ([0-9]+)(?![eE\\.])\n  )\\b\n",
      "captures": {
        "1": {
          "name": "storage.type.imaginary.number.x"
        },
        "2": {
          "name": "invalid.illegal.dec.x"
        }
      }
    },
    "number-hex": {
      "name": "constant.numeric.hex.x",
      "match": "(?x)\n  (?<![\\w\\.])\n    (0[xX]) (_?[0-9a-fA-F])+\n  \\b\n",
      "captures": {
        "1": {
          "name": "storage.type.number.x"
        }
      }
    },
    "number-oct": {
      "name": "constant.numeric.oct.x",
      "match": "(?x)\n  (?<![\\w\\.])\n    (0[oO]) (_?[0-7])+\n  \\b\n",
      "captures": {
        "1": {
          "name": "storage.type.number.x"
        }
      }
    },
    "number-bin": {
      "name": "constant.numeric.bin.x",
      "match": "(?x)\n  (?<![\\w\\.])\n    (0[bB]) (_?[01])+\n  \\b\n",
      "captures": {
        "1": {
          "name": "storage.type.number.x"
        }
      }
    },
    "number-long": {
      "name": "constant.numeric.bin.x",
      "comment": "this is to support python2 syntax for long ints",
      "match": "(?x)\n  (?<![\\w\\.])\n    ([1-9][0-9]* | 0) ([lL])\n  \\b\n",
      "captures": {
        "2": {
          "name": "storage.type.number.x"
        }
      }
    },
    "regexp": {
      "patterns": [
        {
          "include": "#regexp-single-three-line"
        },
        {
          "include": "#regexp-double-three-line"
        },
        {
          "include": "#regexp-single-one-line"
        },
        {
          "include": "#regexp-double-one-line"
        },
        {
          "include": "#fregexp-single-three-line"
        },
        {
          "include": "#fregexp-double-three-line"
        },
        {
          "include": "#fregexp-single-one-line"
        },
        {
          "include": "#fregexp-double-one-line"
        }
      ]
    },
    "string": {
      "patterns": [
        {
          "include": "#string-quoted-multi-line"
        },
        {
          "include": "#string-quoted-single-line"
        },
        {
          "include": "#string-bin-quoted-multi-line"
        },
        {
          "include": "#string-bin-quoted-single-line"
        },
        {
          "include": "#string-raw-quoted-multi-line"
        },
        {
          "include": "#string-raw-quoted-single-line"
        },
        {
          "include": "#string-raw-bin-quoted-multi-line"
        },
        {
          "include": "#string-raw-bin-quoted-single-line"
        },
        {
          "include": "#fstring-fnorm-quoted-multi-line"
        },
        {
          "include": "#fstring-fnorm-quoted-single-line"
        },
        {
          "include": "#fstring-normf-quoted-multi-line"
        },
        {
          "include": "#fstring-normf-quoted-single-line"
        },
        {
          "include": "#fstring-raw-quoted-multi-line"
        },
        {
          "include": "#fstring-raw-quoted-single-line"
        }
      ]
    },
    "string-unicode-guts": {
      "patterns": [
        {
          "include": "#escape-sequence-unicode"
        },
        {
          "include": "#string-entity"
        },
        {
          "include": "#string-brace-formatting"
        }
      ]
    },
    "string-consume-escape": {
      "match": "\\\\['\"\\n\\\\]"
    },
    "string-raw-guts": {
      "patterns": [
        {
          "include": "#string-consume-escape"
        },
        {
          "include": "#string-formatting"
        },
        {
          "include": "#string-brace-formatting"
        }
      ]
    },
    "string-raw-bin-guts": {
      "patterns": [
        {
          "include": "#string-consume-escape"
        },
        {
          "include": "#string-formatting"
        }
      ]
    },
    "string-entity": {
      "patterns": [
        {
          "include": "#escape-sequence"
        },
        {
          "include": "#string-line-continuation"
        },
        {
          "include": "#string-formatting"
        }
      ]
    },
    "fstring-guts": {
      "patterns": [
        {
          "include": "#escape-sequence-unicode"
        },
        {
          "include": "#escape-sequence"
        },
        {
          "include": "#string-line-continuation"
        },
        {
          "include": "#fstring-formatting"
        }
      ]
    },
    "fstring-raw-guts": {
      "patterns": [
        {
          "include": "#string-consume-escape"
        },
        {
          "include": "#fstring-formatting"
        }
      ]
    },
    "fstring-illegal-single-brace": {
      "comment": "it is illegal to have a multiline brace inside a single-line string",
      "begin": "(\\{)(?=[^\\n}]*$\\n?)",
      "end": "(\\})|(?=\\n)",
      "beginCaptures": {
        "1": {
          "name": "constant.character.format.placeholder.other.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "constant.character.format.placeholder.other.x"
        }
      },
      "patterns": [
        {
          "include": "#fstring-terminator-single"
        },
        {
          "include": "#f-expression"
        }
      ]
    },
    "fstring-illegal-multi-brace": {
      "patterns": [
        {
          "include": "#impossible"
        }
      ]
    },
    "f-expression": {
      "comment": "All valid Python expressions, except comments and line continuation",
      "patterns": [
        {
          "include": "#expression-bare"
        },
        {
          "include": "#member-access"
        },
        {
          "comment": "Tokenize identifiers to help linters",
          "match": "(?x) \\b ([[:alpha:]_]\\w*) \\b"
        }
      ]
    },
    "escape-sequence-unicode": {
      "patterns": [
        {
          "name": "constant.character.escape.x",
          "match": "(?x)\n  \\\\ (\n        u[0-9A-Fa-f]{4}\n        | U[0-9A-Fa-f]{8}\n        | N\\{[\\w\\s]+?\\}\n     )\n"
        }
      ]
    },
    "escape-sequence": {
      "name": "constant.character.escape.x",
      "match": "(?x)\n  \\\\ (\n        x[0-9A-Fa-f]{2}\n        | [0-7]{1,3}\n        | [\\\\\"'abfnrtv]\n     )\n"
    },
    "string-line-continuation": {
      "name": "constant.language.x",
      "match": "\\\\$"
    },
    "string-formatting": {
      "name": "meta.format.percent.x",
      "match": "(?x)\n  (\n    % (\\([\\w\\s]*\\))?\n      [-+#0 ]*\n      (\\d+|\\*)? (\\.(\\d+|\\*))?\n      ([hlL])?\n      [diouxXeEfFgGcrsab%]\n  )\n",
      "captures": {
        "1": {
          "name": "constant.character.format.placeholder.other.x"
        }
      }
    },
    "string-brace-formatting": {
      "patterns": [
        {
          "name": "meta.format.brace.x",
          "match": "(?x)\n  (\n    {{ | }}\n    | (?:\n      {\n        \\w* (\\.[[:alpha:]_]\\w* | \\[[^\\]'\"]+\\])*\n        (![rsa])?\n        ( : \\w? [<>=^]? [-+ ]? \\#?\n          \\d* ,? (\\.\\d+)? [bcdeEfFgGnosxX%]? )?\n      })\n  )\n",
          "captures": {
            "1": {
              "name": "constant.character.format.placeholder.other.x"
            },
            "3": {
              "name": "storage.type.format.x"
            },
            "4": {
              "name": "storage.type.format.x"
            }
          }
        },
        {
          "name": "meta.format.brace.x",
          "match": "(?x)\n  (\n    {\n      \\w* (\\.[[:alpha:]_]\\w* | \\[[^\\]'\"]+\\])*\n      (![rsa])?\n      (:)\n        [^'\"{}\\n]* (?:\n          \\{ [^'\"}\\n]*? \\} [^'\"{}\\n]*\n        )*\n    }\n  )\n",
          "captures": {
            "1": {
              "name": "constant.character.format.placeholder.other.x"
            },
            "3": {
              "name": "storage.type.format.x"
            },
            "4": {
              "name": "storage.type.format.x"
            }
          }
        }
      ]
    },
    "fstring-formatting": {
      "patterns": [
        {
          "include": "#fstring-formatting-braces"
        },
        {
          "include": "#fstring-formatting-singe-brace"
        }
      ]
    },
    "fstring-formatting-singe-brace": {
      "name": "invalid.illegal.brace.x",
      "match": "(}(?!}))"
    },
    "import": {
      "comment": "Import statements used to correctly mark `from`, `import`, and `as`\n",
      "patterns": [
        {
          "begin": "\\b(?<!\\.)(from)\\b(?=.+import)",
          "end": "$|(?=import)",
          "beginCaptures": {
            "1": {
              "name": "keyword.control.import.x"
            }
          },
          "patterns": [
            {
              "name": "punctuation.separator.period.x",
              "match": "\\.+"
            },
            {
              "include": "#expression"
            }
          ]
        },
        {
          "begin": "\\b(?<!\\.)(import)\\b",
          "end": "$",
          "beginCaptures": {
            "1": {
              "name": "keyword.control.import.x"
            }
          },
          "patterns": [
            {
              "name": "keyword.control.import.x",
              "match": "\\b(?<!\\.)as\\b"
            },
            {
              "include": "#expression"
            }
          ]
        }
      ]
    },
    "class-declaration": {
      "patterns": [
        {
          "name": "meta.class.x",
          "begin": "(?x)\n  \\s*(class)\\s+\n    (?=\n      [[:alpha:]_]\\w* \\s* (:|\\()\n    )\n",
          "end": "(:)",
          "beginCaptures": {
            "1": {
              "name": "storage.type.class.x"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.section.class.begin.x"
            }
          },
          "patterns": [
            {
              "include": "#class-name"
            },
            {
              "include": "#class-inheritance"
            }
          ]
        }
      ]
    },
    "class-name": {
      "patterns": [
        {
          "include": "#illegal-object-name"
        },
        {
          "include": "#builtin-possible-callables"
        },
        {
          "name": "entity.name.type.class.x",
          "match": "(?x)\n  \\b ([[:alpha:]_]\\w*) \\b\n"
        }
      ]
    },
    "class-inheritance": {
      "name": "meta.class.inheritance.x",
      "begin": "(\\()",
      "end": "(\\))",
      "beginCaptures": {
        "1": {
          "name": "punctuation.definition.inheritance.begin.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.inheritance.end.x"
        }
      },
      "patterns": [
        {
          "name": "keyword.operator.unpacking.arguments.x",
          "match": "(\\*\\*|\\*)"
        },
        {
          "name": "punctuation.separator.inheritance.x",
          "match": ","
        },
        {
          "name": "keyword.operator.assignment.x",
          "match": "=(?!=)"
        },
        {
          "name": "support.type.metaclass.x",
          "match": "\\bmetaclass\\b"
        },
        {
          "include": "#illegal-names"
        },
        {
          "include": "#class-kwarg"
        },
        {
          "include": "#call-wrapper-inheritance"
        },
        {
          "include": "#expression-base"
        },
        {
          "include": "#member-access-class"
        },
        {
          "include": "#inheritance-identifier"
        }
      ]
    },
    "class-kwarg": {
      "match": "(?x)\n  \\b ([[:alpha:]_]\\w*) \\s*(=)(?!=)\n",
      "captures": {
        "1": {
          "name": "entity.other.inherited-class.x variable.parameter.class.x"
        },
        "2": {
          "name": "keyword.operator.assignment.x"
        }
      }
    },
    "inheritance-identifier": {
      "match": "(?x)\n  \\b ([[:alpha:]_]\\w*) \\b\n",
      "captures": {
        "1": {
          "name": "entity.other.inherited-class.x"
        }
      }
    },
    "member-access-class": {
      "name": "meta.member.access.x",
      "begin": "(\\.)\\s*(?!\\.)",
      "end": "(?<=\\S)(?=\\W)|$",
      "beginCaptures": {
        "1": {
          "name": "punctuation.separator.period.x"
        }
      },
      "patterns": [
        {
          "include": "#call-wrapper-inheritance"
        },
        {
          "include": "#member-access-base"
        },
        {
          "include": "#inheritance-identifier"
        }
      ]
    },
    "lambda": {
      "patterns": [
        {
          "match": "((?<=\\.)lambda|lambda(?=\\s*[\\.=]))",
          "captures": {
            "1": {
              "name": "keyword.control.flow.x"
            }
          }
        },
        {
          "match": "\\b(lambda)\\s*?(?=[,\\n]|$)",
          "captures": {
            "1": {
              "name": "storage.type.function.lambda.x"
            }
          }
        },
        {
          "name": "meta.lambda-function.x",
          "begin": "(?x)\n  \\b (lambda) \\b\n",
          "end": "(:)|(\\n)",
          "beginCaptures": {
            "1": {
              "name": "storage.type.function.lambda.x"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.section.function.lambda.begin.x"
            }
          },
          "contentName": "meta.function.lambda.parameters.x",
          "patterns": [
            {
              "name": "keyword.operator.unpacking.parameter.x",
              "match": "(\\*\\*|\\*)"
            },
            {
              "include": "#lambda-nested-incomplete"
            },
            {
              "include": "#illegal-names"
            },
            {
              "match": "([[:alpha:]_]\\w*)\\s*(?:(,)|(?=:|$))",
              "captures": {
                "1": {
                  "name": "variable.parameter.function.language.x"
                },
                "2": {
                  "name": "punctuation.separator.parameters.x"
                }
              }
            },
            {
              "include": "#comments"
            },
            {
              "include": "#backticks"
            },
            {
              "include": "#illegal-anno"
            },
            {
              "include": "#lambda-parameter-with-default"
            },
            {
              "include": "#line-continuation"
            },
            {
              "include": "#illegal-operator"
            }
          ]
        }
      ]
    },
    "lambda-incomplete": {
      "name": "storage.type.function.lambda.x",
      "match": "\\blambda(?=\\s*[,)])"
    },
    "lambda-nested-incomplete": {
      "name": "storage.type.function.lambda.x",
      "match": "\\blambda(?=\\s*[:,)])"
    },
    "lambda-parameter-with-default": {
      "begin": "(?x)\n  \\b\n  ([[:alpha:]_]\\w*) \\s* (=)\n",
      "end": "(,)|(?=:|$)",
      "beginCaptures": {
        "1": {
          "name": "variable.parameter.function.language.x"
        },
        "2": {
          "name": "keyword.operator.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.separator.parameters.x"
        }
      },
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "generator": {
      "comment": "Match \"for ... in\" construct used in generators and for loops to\ncorrectly identify the \"in\" as a control flow keyword.\n",
      "begin": "\\bfor\\b",
      "beginCaptures": {
        "0": {
          "name": "keyword.control.flow.x"
        }
      },
      "end": "\\bin\\b",
      "endCaptures": {
        "0": {
          "name": "keyword.control.flow.x"
        }
      },
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "function-declaration": {
      "name": "meta.function.x",
      "begin": "(?x)\n  \\s*\n  (?:\\b(async) \\s+)? \\b(def)\\s+\n    (?=\n      [[:alpha:]_][[:word:]]* \\s* \\(\n    )\n",
      "end": "(:|(?=[#'\"\\n]))",
      "beginCaptures": {
        "1": {
          "name": "storage.type.function.async.x"
        },
        "2": {
          "name": "storage.type.function.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.section.function.begin.x"
        }
      },
      "patterns": [
        {
          "include": "#function-def-name"
        },
        {
          "include": "#parameters"
        },
        {
          "include": "#line-continuation"
        },
        {
          "include": "#return-annotation"
        }
      ]
    },
    "function-def-name": {
      "patterns": [
        {
          "include": "#illegal-object-name"
        },
        {
          "include": "#builtin-possible-callables"
        },
        {
          "name": "entity.name.function.x",
          "match": "(?x)\n  \\b ([[:alpha:]_]\\w*) \\b\n"
        }
      ]
    },
    "parameters": {
      "name": "meta.function.parameters.x",
      "begin": "(\\()",
      "end": "(\\))",
      "beginCaptures": {
        "1": {
          "name": "punctuation.definition.parameters.begin.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.parameters.end.x"
        }
      },
      "patterns": [
        {
          "name": "keyword.operator.unpacking.parameter.x",
          "match": "(\\*\\*|\\*)"
        },
        {
          "include": "#lambda-incomplete"
        },
        {
          "include": "#illegal-names"
        },
        {
          "include": "#illegal-object-name"
        },
        {
          "include": "#parameter-special"
        },
        {
          "match": "(?x)\n  ([[:alpha:]_]\\w*)\n    \\s* (?: (,) | (?=[)#\\n=]))\n",
          "captures": {
            "1": {
              "name": "variable.parameter.function.language.x"
            },
            "2": {
              "name": "punctuation.separator.parameters.x"
            }
          }
        },
        {
          "include": "#comments"
        },
        {
          "include": "#loose-default"
        },
        {
          "include": "#annotated-parameter"
        }
      ]
    },
    "parameter-special": {
      "match": "(?x)\n  \\b ((self)|(cls)) \\b \\s*(?:(,)|(?=\\)))\n",
      "captures": {
        "1": {
          "name": "variable.parameter.function.language.x"
        },
        "2": {
          "name": "variable.parameter.function.language.special.self.x"
        },
        "3": {
          "name": "variable.parameter.function.language.special.cls.x"
        },
        "4": {
          "name": "punctuation.separator.parameters.x"
        }
      }
    },
    "loose-default": {
      "begin": "(=)",
      "end": "(,)|(?=\\))",
      "beginCaptures": {
        "1": {
          "name": "keyword.operator.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.separator.parameters.x"
        }
      },
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "annotated-parameter": {
      "begin": "(?x)\n  \\b\n  ([[:alpha:]_]\\w*) \\s* (:)\n",
      "end": "(,)|(?=\\))",
      "beginCaptures": {
        "1": {
          "name": "variable.parameter.function.language.x"
        },
        "2": {
          "name": "punctuation.separator.annotation.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.separator.parameters.x"
        }
      },
      "patterns": [
        {
          "include": "#expression"
        },
        {
          "name": "keyword.operator.assignment.x",
          "match": "=(?!=)"
        }
      ]
    },
    "return-annotation": {
      "begin": "(->)",
      "end": "(?=:)",
      "beginCaptures": {
        "1": {
          "name": "punctuation.separator.annotation.result.x"
        }
      },
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "item-access": {
      "patterns": [
        {
          "name": "meta.item-access.x",
          "begin": "(?x)\n  \\b(?=\n    [[:alpha:]_]\\w* \\s* \\[\n  )\n",
          "end": "(\\])",
          "endCaptures": {
            "1": {
              "name": "punctuation.definition.arguments.end.x"
            }
          },
          "patterns": [
            {
              "include": "#item-name"
            },
            {
              "include": "#item-index"
            },
            {
              "include": "#expression"
            }
          ]
        }
      ]
    },
    "item-name": {
      "patterns": [
        {
          "include": "#special-variables"
        },
        {
          "include": "#builtin-functions"
        },
        {
          "include": "#special-names"
        },
        {
          "name": "meta.indexed-name.x",
          "match": "(?x)\n  \\b ([[:alpha:]_]\\w*) \\b\n"
        }
      ]
    },
    "item-index": {
      "begin": "(\\[)",
      "end": "(?=\\])",
      "beginCaptures": {
        "1": {
          "name": "punctuation.definition.arguments.begin.x"
        }
      },
      "contentName": "meta.item-access.arguments.x",
      "patterns": [
        {
          "name": "punctuation.separator.slice.x",
          "match": ":"
        },
        {
          "include": "#expression"
        }
      ]
    },
    "decorator": {
      "name": "meta.function.decorator.x",
      "begin": "(?x)\n  ^\\s*\n  ((@)) \\s* (?=[[:alpha:]_]\\w*)\n",
      "end": "(?x)\n  ( \\) )\n    # trailing whitespace and comments are legal\n    (?: (.*?) (?=\\s*(?:\\#|$)) )\n  | (?=\\n|\\#)\n",
      "beginCaptures": {
        "1": {
          "name": "entity.name.function.decorator.x"
        },
        "2": {
          "name": "punctuation.definition.decorator.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.arguments.end.x"
        },
        "2": {
          "name": "invalid.illegal.decorator.x"
        }
      },
      "patterns": [
        {
          "include": "#decorator-name"
        },
        {
          "include": "#function-arguments"
        }
      ]
    },
    "decorator-name": {
      "patterns": [
        {
          "include": "#builtin-callables"
        },
        {
          "include": "#illegal-object-name"
        },
        {
          "name": "entity.name.function.decorator.x",
          "match": "(?x)\n  ([[:alpha:]_]\\w*) | (\\.)\n",
          "captures": {
            "2": {
              "name": "punctuation.separator.period.x"
            }
          }
        },
        {
          "include": "#line-continuation"
        },
        {
          "name": "invalid.illegal.decorator.x",
          "match": "(?x)\n  \\s* ([^([:alpha:]\\s_\\.#\\\\] .*?) (?=\\#|$)\n",
          "captures": {
            "1": {
              "name": "invalid.illegal.decorator.x"
            }
          }
        }
      ]
    },
    "call-wrapper-inheritance": {
      "comment": "same as a function call, but in inheritance context",
      "name": "meta.function-call.x",
      "begin": "(?x)\n  \\b(?=\n    ([[:alpha:]_]\\w*) \\s* (\\()\n  )\n",
      "end": "(\\))",
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.arguments.end.x"
        }
      },
      "patterns": [
        {
          "include": "#inheritance-name"
        },
        {
          "include": "#function-arguments"
        }
      ]
    },
    "inheritance-name": {
      "patterns": [
        {
          "include": "#lambda-incomplete"
        },
        {
          "include": "#builtin-possible-callables"
        },
        {
          "include": "#inheritance-identifier"
        }
      ]
    },
    "function-call": {
      "name": "meta.function-call.x",
      "comment": "Regular function call of the type \"name(args)\"",
      "begin": "(?x)\n  \\b(?=\n    ([[:alpha:]_]\\w*) \\s* (\\()\n  )\n",
      "end": "(\\))",
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.arguments.end.x"
        }
      },
      "patterns": [
        {
          "include": "#special-variables"
        },
        {
          "include": "#function-name"
        },
        {
          "include": "#function-arguments"
        }
      ]
    },
    "function-name": {
      "patterns": [
        {
          "include": "#builtin-possible-callables"
        },
        {
          "comment": "Some color schemas support meta.function-call.generic scope",
          "name": "meta.function-call.generic.x",
          "match": "(?x)\n  \\b ([[:alpha:]_]\\w*) \\b\n"
        }
      ]
    },
    "function-arguments": {
      "begin": "(\\()",
      "end": "(?=\\))(?!\\)\\s*\\()",
      "beginCaptures": {
        "1": {
          "name": "punctuation.definition.arguments.begin.x"
        }
      },
      "contentName": "meta.function-call.arguments.x",
      "patterns": [
        {
          "name": "punctuation.separator.arguments.x",
          "match": "(,)"
        },
        {
          "match": "(?x)\n  (?:(?<=[,(])|^) \\s* (\\*{1,2})\n",
          "captures": {
            "1": {
              "name": "keyword.operator.unpacking.arguments.x"
            }
          }
        },
        {
          "include": "#lambda-incomplete"
        },
        {
          "include": "#illegal-names"
        },
        {
          "match": "\\b([[:alpha:]_]\\w*)\\s*(=)(?!=)",
          "captures": {
            "1": {
              "name": "variable.parameter.function-call.x"
            },
            "2": {
              "name": "keyword.operator.assignment.x"
            }
          }
        },
        {
          "name": "keyword.operator.assignment.x",
          "match": "=(?!=)"
        },
        {
          "include": "#expression"
        },
        {
          "match": "\\s*(\\))\\s*(\\()",
          "captures": {
            "1": {
              "name": "punctuation.definition.arguments.end.x"
            },
            "2": {
              "name": "punctuation.definition.arguments.begin.x"
            }
          }
        }
      ]
    },
    "builtin-callables": {
      "patterns": [
        {
          "include": "#illegal-names"
        },
        {
          "include": "#illegal-object-name"
        },
        {
          "include": "#builtin-exceptions"
        },
        {
          "include": "#builtin-functions"
        },
        {
          "include": "#builtin-types"
        }
      ]
    },
    "builtin-possible-callables": {
      "patterns": [
        {
          "include": "#builtin-callables"
        },
        {
          "include": "#magic-names"
        }
      ]
    },
    "builtin-exceptions": {
      "name": "support.type.exception.x",
      "match": "(?x) (?<!\\.) \\b(\n  (\n    Arithmetic | Assertion | Attribute | Buffer | BlockingIO\n    | BrokenPipe | ChildProcess\n    | (Connection (Aborted | Refused | Reset)?)\n    | EOF | Environment | FileExists | FileNotFound\n    | FloatingPoint | IO | Import | Indentation | Index | Interrupted\n    | IsADirectory | NotADirectory | Permission | ProcessLookup\n    | Timeout\n    | Key | Lookup | Memory | Name | NotImplemented | OS | Overflow\n    | Reference | Runtime | Recursion | Syntax | System\n    | Tab | Type | UnboundLocal | Unicode(Encode|Decode|Translate)?\n    | Value | Windows | ZeroDivision | ModuleNotFound\n  ) Error\n|\n  ((Pending)?Deprecation | Runtime | Syntax | User | Future | Import\n    | Unicode | Bytes | Resource\n  )? Warning\n|\n  SystemExit | Stop(Async)?Iteration\n  | KeyboardInterrupt\n  | GeneratorExit | (Base)?Exception\n)\\b\n"
    },
    "builtin-functions": {
      "patterns": [
        {
          "name": "support.function.builtin.x",
          "match": "(?x)\n  (?<!\\.) \\b(\n    __import__ | abs | all | any | ascii | bin | breakpoint | callable\n    | chr | compile | copyright | credits | delattr | dir | divmod\n    | enumerate | eval | exec | exit | filter | format | getattr\n    | globals | hasattr | hash | help | hex | id | input\n    | isinstance | issubclass | iter | len | license | locals | map\n    | max | memoryview | min | next | oct | open | ord | pow | print\n    | quit | range | reload | repr | reversed | round\n    | setattr | sorted | sum | vars | zip\n  )\\b\n"
        },
        {
          "name": "variable.legacy.builtin.x",
          "match": "(?x)\n  (?<!\\.) \\b(\n    file | reduce | intern | raw_input | unicode | cmp | basestring\n    | execfile | long | xrange\n  )\\b\n"
        }
      ]
    },
    "builtin-types": {
      "name": "support.type.x",
      "match": "(?x)\n  (?<!\\.) \\b(\n    bool | bytearray | bytes | classmethod | complex | dict\n    | float | frozenset | int | list | object | property\n    | set | slice | staticmethod | str | tuple | type\n\n    (?# Although 'super' is not a type, it's related to types,\n        and is special enough to be highlighted differently from\n        other built-ins)\n    | super\n  )\\b\n"
    },
    "magic-function-names": {
      "comment": "these methods have magic interpretation by python and are generally called\nindirectly through syntactic constructs\n",
      "match": "(?x)\n  \\b(\n    __(?:\n      abs | add | aenter | aexit | aiter | and | anext | await\n      | bool | call | ceil | cmp | coerce | complex | contains\n      | copy | deepcopy | del | delattr | delete | delitem\n      | delslice | dir | div | divmod | enter | eq | exit | float\n      | floor | floordiv | format | ge | get | getattr\n      | getattribute | getinitargs | getitem | getnewargs\n      | getslice | getstate | gt | hash | hex | iadd | iand | idiv\n      | ifloordiv | ilshift | imod | imul | index | init\n      | instancecheck | int | invert | ior | ipow | irshift | isub\n      | iter | itruediv | ixor | le | len | long | lshift | lt\n      | missing | mod | mul | ne | neg | new | next | nonzero | oct | or\n      | pos | pow | radd | rand | rdiv | rdivmod | reduce\n      | reduce_ex | repr | reversed | rfloordiv | rlshift | rmod\n      | rmul | ror | round | rpow | rrshift | rshift | rsub\n      | rtruediv | rxor | set | setattr | setitem | setslice\n      | setstate | sizeof | str | sub | subclasscheck | truediv\n      | trunc | unicode | xor | matmul | rmatmul | imatmul\n      | init_subclass | set_name | fspath | bytes | prepare\n    )__\n  )\\b\n",
      "captures": {
        "1": {
          "name": "support.function.magic.x"
        }
      }
    },
    "magic-variable-names": {
      "comment": "magic variables which a class/module may have.",
      "match": "(?x)\n  \\b(\n    __(?:\n      all | bases | builtins | class | class_getitem | code | debug\n      | defaults | dict | doc | file | func | kwdefaults | members\n      | metaclass | methods | module | mro | mro_entries | name\n      | qualname | post_init | self | signature | slots | subclasses\n      | version | weakref | wrapped | annotations | classcell\n      | spec | path | package | future | traceback\n    )__\n  )\\b\n",
      "captures": {
        "1": {
          "name": "support.variable.magic.x"
        }
      }
    },
    "magic-names": {
      "patterns": [
        {
          "include": "#magic-function-names"
        },
        {
          "include": "#magic-variable-names"
        }
      ]
    },
    "illegal-names": {
      "match": "(?x)\n  \\b(?:\n    (\n      and | assert | async | await | break | class | continue | def\n      | del | elif | else | except | finally | for | from | global\n      | if | in | is | (?<=\\.)lambda | lambda(?=\\s*[\\.=])\n      | nonlocal | not | or | pass | raise | return | try | while | with\n      | yield\n    ) | (\n      as | import\n    )\n  )\\b\n",
      "captures": {
        "1": {
          "name": "keyword.control.flow.x"
        },
        "2": {
          "name": "keyword.control.import.x"
        }
      }
    },
    "special-variables": {
      "match": "(?x)\n  \\b (?<!\\.) (?:\n    (self) | (cls)\n  )\\b\n",
      "captures": {
        "1": {
          "name": "variable.language.special.self.x"
        },
        "2": {
          "name": "variable.language.special.cls.x"
        }
      }
    },
    "ellipsis": {
      "name": "constant.other.ellipsis.x",
      "match": "\\.\\.\\."
    },
    "backticks": {
      "name": "invalid.deprecated.backtick.x",
      "begin": "\\`",
      "end": "(?:\\`|(?<!\\\\)(\\n))",
      "patterns": [
        {
          "include": "#expression"
        }
      ]
    },
    "illegal-operator": {
      "patterns": [
        {
          "name": "invalid.illegal.operator.x",
          "match": "&&|\\|\\||--|\\+\\+"
        },
        {
          "name": "invalid.illegal.operator.x",
          "match": "[?$]"
        },
        {
          "name": "invalid.illegal.operator.x",
          "comment": "We don't want `!` to flash when we're typing `!=`",
          "match": "!\\b"
        }
      ]
    },
    "illegal-object-name": {
      "comment": "It's illegal to name class or function \"True\"",
      "name": "keyword.illegal.name.x",
      "match": "\\b(True|False|None)\\b"
    },
    "illegal-anno": {
      "name": "invalid.illegal.annotation.x",
      "match": "->"
    },
    "regexp-base-expression": {
      "patterns": [
        {
          "include": "#regexp-quantifier"
        },
        {
          "include": "#regexp-base-common"
        }
      ]
    },
    "fregexp-base-expression": {
      "patterns": [
        {
          "include": "#fregexp-quantifier"
        },
        {
          "include": "#fstring-formatting-braces"
        },
        {
          "match": "\\{.*?\\}"
        },
        {
          "include": "#regexp-base-common"
        }
      ]
    },
    "fstring-formatting-braces": {
      "patterns": [
        {
          "comment": "empty braces are illegal",
          "match": "({)(\\s*?)(})",
          "captures": {
            "1": {
              "name": "constant.character.format.placeholder.other.x"
            },
            "2": {
              "name": "invalid.illegal.brace.x"
            },
            "3": {
              "name": "constant.character.format.placeholder.other.x"
            }
          }
        },
        {
          "name": "constant.character.escape.x",
          "match": "({{|}})"
        }
      ]
    },
    "regexp-base-common": {
      "patterns": [
        {
          "name": "support.other.match.any.regexp",
          "match": "\\."
        },
        {
          "name": "support.other.match.begin.regexp",
          "match": "\\^"
        },
        {
          "name": "support.other.match.end.regexp",
          "match": "\\$"
        },
        {
          "name": "keyword.operator.quantifier.regexp",
          "match": "[+*?]\\??"
        },
        {
          "name": "keyword.operator.disjunction.regexp",
          "match": "\\|"
        },
        {
          "include": "#regexp-escape-sequence"
        }
      ]
    },
    "regexp-quantifier": {
      "name": "keyword.operator.quantifier.regexp",
      "match": "(?x)\n  \\{(\n    \\d+ | \\d+,(\\d+)? | ,\\d+\n  )\\}\n"
    },
    "fregexp-quantifier": {
      "name": "keyword.operator.quantifier.regexp",
      "match": "(?x)\n  \\{\\{(\n    \\d+ | \\d+,(\\d+)? | ,\\d+\n  )\\}\\}\n"
    },
    "regexp-backreference-number": {
      "name": "meta.backreference.regexp",
      "match": "(\\\\[1-9]\\d?)",
      "captures": {
        "1": {
          "name": "entity.name.tag.backreference.regexp"
        }
      }
    },
    "regexp-backreference": {
      "name": "meta.backreference.named.regexp",
      "match": "(?x)\n  (\\()  (\\?P= \\w+(?:\\s+[[:alnum:]]+)?)  (\\))\n",
      "captures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.backreference.named.begin.regexp"
        },
        "2": {
          "name": "entity.name.tag.named.backreference.regexp"
        },
        "3": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.backreference.named.end.regexp"
        }
      }
    },
    "regexp-flags": {
      "name": "storage.modifier.flag.regexp",
      "match": "\\(\\?[aiLmsux]+\\)"
    },
    "regexp-escape-special": {
      "name": "support.other.escape.special.regexp",
      "match": "\\\\([AbBdDsSwWZ])"
    },
    "regexp-escape-character": {
      "name": "constant.character.escape.regexp",
      "match": "(?x)\n  \\\\ (\n        x[0-9A-Fa-f]{2}\n        | 0[0-7]{1,2}\n        | [0-7]{3}\n     )\n"
    },
    "regexp-escape-unicode": {
      "name": "constant.character.unicode.regexp",
      "match": "(?x)\n  \\\\ (\n        u[0-9A-Fa-f]{4}\n        | U[0-9A-Fa-f]{8}\n     )\n"
    },
    "regexp-escape-catchall": {
      "name": "constant.character.escape.regexp",
      "match": "\\\\(.|\\n)"
    },
    "regexp-escape-sequence": {
      "patterns": [
        {
          "include": "#regexp-escape-special"
        },
        {
          "include": "#regexp-escape-character"
        },
        {
          "include": "#regexp-escape-unicode"
        },
        {
          "include": "#regexp-backreference-number"
        },
        {
          "include": "#regexp-escape-catchall"
        }
      ]
    },
    "regexp-charecter-set-escapes": {
      "patterns": [
        {
          "name": "constant.character.escape.regexp",
          "match": "\\\\[abfnrtv\\\\]"
        },
        {
          "include": "#regexp-escape-special"
        },
        {
          "name": "constant.character.escape.regexp",
          "match": "\\\\([0-7]{1,3})"
        },
        {
          "include": "#regexp-escape-character"
        },
        {
          "include": "#regexp-escape-unicode"
        },
        {
          "include": "#regexp-escape-catchall"
        }
      ]
    },
    "codetags": {
      "match": "(?:\\b(NOTE|XXX|HACK|FIXME|BUG|TODO)\\b)",
      "captures": {
        "1": {
          "name": "keyword.codetag.notation.x"
        }
      }
    },
    "comments-base": {
      "name": "comment.line.number-sign.x",
      "begin": "(\\#)",
      "beginCaptures": {
        "1": {
          "name": "punctuation.definition.comment.x"
        }
      },
      "end": "($)",
      "patterns": [
        {
          "include": "#codetags"
        }
      ]
    },
    "comments-string-single-three": {
      "name": "comment.line.number-sign.x",
      "begin": "(\\#)",
      "beginCaptures": {
        "1": {
          "name": "punctuation.definition.comment.x"
        }
      },
      "end": "($|(?='''))",
      "patterns": [
        {
          "include": "#codetags"
        }
      ]
    },
    "comments-string-double-three": {
      "name": "comment.line.number-sign.x",
      "begin": "(\\#)",
      "beginCaptures": {
        "1": {
          "name": "punctuation.definition.comment.x"
        }
      },
      "end": "($|(?=\"\"\"))",
      "patterns": [
        {
          "include": "#codetags"
        }
      ]
    },
    "single-one-regexp-expression": {
      "patterns": [
        {
          "include": "#regexp-base-expression"
        },
        {
          "include": "#single-one-regexp-character-set"
        },
        {
          "include": "#single-one-regexp-comments"
        },
        {
          "include": "#regexp-flags"
        },
        {
          "include": "#single-one-regexp-named-group"
        },
        {
          "include": "#regexp-backreference"
        },
        {
          "include": "#single-one-regexp-lookahead"
        },
        {
          "include": "#single-one-regexp-lookahead-negative"
        },
        {
          "include": "#single-one-regexp-lookbehind"
        },
        {
          "include": "#single-one-regexp-lookbehind-negative"
        },
        {
          "include": "#single-one-regexp-conditional"
        },
        {
          "include": "#single-one-regexp-parentheses-non-capturing"
        },
        {
          "include": "#single-one-regexp-parentheses"
        }
      ]
    },
    "single-one-regexp-character-set": {
      "patterns": [
        {
          "match": "(?x)\n  \\[ \\^? \\] (?! .*?\\])\n"
        },
        {
          "name": "meta.character.set.regexp",
          "begin": "(\\[)(\\^)?(\\])?",
          "end": "(\\]|(?=\\'))|((?=(?<!\\\\)\\n))",
          "beginCaptures": {
            "1": {
              "name": "punctuation.character.set.begin.regexp constant.other.set.regexp"
            },
            "2": {
              "name": "keyword.operator.negation.regexp"
            },
            "3": {
              "name": "constant.character.set.regexp"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.character.set.end.regexp constant.other.set.regexp"
            },
            "2": {
              "name": "invalid.illegal.newline.x"
            }
          },
          "patterns": [
            {
              "include": "#regexp-charecter-set-escapes"
            },
            {
              "name": "constant.character.set.regexp",
              "match": "[^\\n]"
            }
          ]
        }
      ]
    },
    "single-one-regexp-named-group": {
      "name": "meta.named.regexp",
      "begin": "(?x)\n  (\\()  (\\?P <\\w+(?:\\s+[[:alnum:]]+)?>)\n",
      "end": "(\\)|(?=\\'))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.named.begin.regexp"
        },
        "2": {
          "name": "entity.name.tag.named.group.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.named.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-one-regexp-expression"
        }
      ]
    },
    "single-one-regexp-comments": {
      "name": "comment.regexp",
      "begin": "\\(\\?#",
      "end": "(\\)|(?=\\'))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "punctuation.comment.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.comment.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#codetags"
        }
      ]
    },
    "single-one-regexp-lookahead": {
      "begin": "(\\()\\?=",
      "end": "(\\)|(?=\\'))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookahead.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookahead.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookahead.regexp punctuation.parenthesis.lookahead.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-one-regexp-expression"
        }
      ]
    },
    "single-one-regexp-lookahead-negative": {
      "begin": "(\\()\\?!",
      "end": "(\\)|(?=\\'))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookahead.negative.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookahead.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookahead.negative.regexp punctuation.parenthesis.lookahead.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-one-regexp-expression"
        }
      ]
    },
    "single-one-regexp-lookbehind": {
      "begin": "(\\()\\?<=",
      "end": "(\\)|(?=\\'))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookbehind.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookbehind.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookbehind.regexp punctuation.parenthesis.lookbehind.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-one-regexp-expression"
        }
      ]
    },
    "single-one-regexp-lookbehind-negative": {
      "begin": "(\\()\\?<!",
      "end": "(\\)|(?=\\'))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookbehind.negative.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookbehind.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.lookbehind.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-one-regexp-expression"
        }
      ]
    },
    "single-one-regexp-conditional": {
      "begin": "(\\()\\?\\((\\w+(?:\\s+[[:alnum:]]+)?|\\d+)\\)",
      "end": "(\\)|(?=\\'))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.conditional.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.conditional.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.conditional.negative.regexp punctuation.parenthesis.conditional.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-one-regexp-expression"
        }
      ]
    },
    "single-one-regexp-parentheses-non-capturing": {
      "begin": "\\(\\?:",
      "end": "(\\)|(?=\\'))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-one-regexp-expression"
        }
      ]
    },
    "single-one-regexp-parentheses": {
      "begin": "\\(",
      "end": "(\\)|(?=\\'))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-one-regexp-expression"
        }
      ]
    },
    "single-three-regexp-expression": {
      "patterns": [
        {
          "include": "#regexp-base-expression"
        },
        {
          "include": "#single-three-regexp-character-set"
        },
        {
          "include": "#single-three-regexp-comments"
        },
        {
          "include": "#regexp-flags"
        },
        {
          "include": "#single-three-regexp-named-group"
        },
        {
          "include": "#regexp-backreference"
        },
        {
          "include": "#single-three-regexp-lookahead"
        },
        {
          "include": "#single-three-regexp-lookahead-negative"
        },
        {
          "include": "#single-three-regexp-lookbehind"
        },
        {
          "include": "#single-three-regexp-lookbehind-negative"
        },
        {
          "include": "#single-three-regexp-conditional"
        },
        {
          "include": "#single-three-regexp-parentheses-non-capturing"
        },
        {
          "include": "#single-three-regexp-parentheses"
        },
        {
          "include": "#comments-string-single-three"
        }
      ]
    },
    "single-three-regexp-character-set": {
      "patterns": [
        {
          "match": "(?x)\n  \\[ \\^? \\] (?! .*?\\])\n"
        },
        {
          "name": "meta.character.set.regexp",
          "begin": "(\\[)(\\^)?(\\])?",
          "end": "(\\]|(?=\\'\\'\\'))",
          "beginCaptures": {
            "1": {
              "name": "punctuation.character.set.begin.regexp constant.other.set.regexp"
            },
            "2": {
              "name": "keyword.operator.negation.regexp"
            },
            "3": {
              "name": "constant.character.set.regexp"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.character.set.end.regexp constant.other.set.regexp"
            },
            "2": {
              "name": "invalid.illegal.newline.x"
            }
          },
          "patterns": [
            {
              "include": "#regexp-charecter-set-escapes"
            },
            {
              "name": "constant.character.set.regexp",
              "match": "[^\\n]"
            }
          ]
        }
      ]
    },
    "single-three-regexp-named-group": {
      "name": "meta.named.regexp",
      "begin": "(?x)\n  (\\()  (\\?P <\\w+(?:\\s+[[:alnum:]]+)?>)\n",
      "end": "(\\)|(?=\\'\\'\\'))",
      "beginCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.named.begin.regexp"
        },
        "2": {
          "name": "entity.name.tag.named.group.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.named.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-three-regexp-expression"
        },
        {
          "include": "#comments-string-single-three"
        }
      ]
    },
    "single-three-regexp-comments": {
      "name": "comment.regexp",
      "begin": "\\(\\?#",
      "end": "(\\)|(?=\\'\\'\\'))",
      "beginCaptures": {
        "0": {
          "name": "punctuation.comment.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.comment.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#codetags"
        }
      ]
    },
    "single-three-regexp-lookahead": {
      "begin": "(\\()\\?=",
      "end": "(\\)|(?=\\'\\'\\'))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookahead.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookahead.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookahead.regexp punctuation.parenthesis.lookahead.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-three-regexp-expression"
        },
        {
          "include": "#comments-string-single-three"
        }
      ]
    },
    "single-three-regexp-lookahead-negative": {
      "begin": "(\\()\\?!",
      "end": "(\\)|(?=\\'\\'\\'))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookahead.negative.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookahead.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookahead.negative.regexp punctuation.parenthesis.lookahead.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-three-regexp-expression"
        },
        {
          "include": "#comments-string-single-three"
        }
      ]
    },
    "single-three-regexp-lookbehind": {
      "begin": "(\\()\\?<=",
      "end": "(\\)|(?=\\'\\'\\'))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookbehind.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookbehind.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookbehind.regexp punctuation.parenthesis.lookbehind.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-three-regexp-expression"
        },
        {
          "include": "#comments-string-single-three"
        }
      ]
    },
    "single-three-regexp-lookbehind-negative": {
      "begin": "(\\()\\?<!",
      "end": "(\\)|(?=\\'\\'\\'))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookbehind.negative.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookbehind.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.lookbehind.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-three-regexp-expression"
        },
        {
          "include": "#comments-string-single-three"
        }
      ]
    },
    "single-three-regexp-conditional": {
      "begin": "(\\()\\?\\((\\w+(?:\\s+[[:alnum:]]+)?|\\d+)\\)",
      "end": "(\\)|(?=\\'\\'\\'))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.conditional.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.conditional.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.conditional.negative.regexp punctuation.parenthesis.conditional.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-three-regexp-expression"
        },
        {
          "include": "#comments-string-single-three"
        }
      ]
    },
    "single-three-regexp-parentheses-non-capturing": {
      "begin": "\\(\\?:",
      "end": "(\\)|(?=\\'\\'\\'))",
      "beginCaptures": {
        "0": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-three-regexp-expression"
        },
        {
          "include": "#comments-string-single-three"
        }
      ]
    },
    "single-three-regexp-parentheses": {
      "begin": "\\(",
      "end": "(\\)|(?=\\'\\'\\'))",
      "beginCaptures": {
        "0": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-three-regexp-expression"
        },
        {
          "include": "#comments-string-single-three"
        }
      ]
    },
    "double-one-regexp-expression": {
      "patterns": [
        {
          "include": "#regexp-base-expression"
        },
        {
          "include": "#double-one-regexp-character-set"
        },
        {
          "include": "#double-one-regexp-comments"
        },
        {
          "include": "#regexp-flags"
        },
        {
          "include": "#double-one-regexp-named-group"
        },
        {
          "include": "#regexp-backreference"
        },
        {
          "include": "#double-one-regexp-lookahead"
        },
        {
          "include": "#double-one-regexp-lookahead-negative"
        },
        {
          "include": "#double-one-regexp-lookbehind"
        },
        {
          "include": "#double-one-regexp-lookbehind-negative"
        },
        {
          "include": "#double-one-regexp-conditional"
        },
        {
          "include": "#double-one-regexp-parentheses-non-capturing"
        },
        {
          "include": "#double-one-regexp-parentheses"
        }
      ]
    },
    "double-one-regexp-character-set": {
      "patterns": [
        {
          "match": "(?x)\n  \\[ \\^? \\] (?! .*?\\])\n"
        },
        {
          "name": "meta.character.set.regexp",
          "begin": "(\\[)(\\^)?(\\])?",
          "end": "(\\]|(?=\"))|((?=(?<!\\\\)\\n))",
          "beginCaptures": {
            "1": {
              "name": "punctuation.character.set.begin.regexp constant.other.set.regexp"
            },
            "2": {
              "name": "keyword.operator.negation.regexp"
            },
            "3": {
              "name": "constant.character.set.regexp"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.character.set.end.regexp constant.other.set.regexp"
            },
            "2": {
              "name": "invalid.illegal.newline.x"
            }
          },
          "patterns": [
            {
              "include": "#regexp-charecter-set-escapes"
            },
            {
              "name": "constant.character.set.regexp",
              "match": "[^\\n]"
            }
          ]
        }
      ]
    },
    "double-one-regexp-named-group": {
      "name": "meta.named.regexp",
      "begin": "(?x)\n  (\\()  (\\?P <\\w+(?:\\s+[[:alnum:]]+)?>)\n",
      "end": "(\\)|(?=\"))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.named.begin.regexp"
        },
        "2": {
          "name": "entity.name.tag.named.group.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.named.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-one-regexp-expression"
        }
      ]
    },
    "double-one-regexp-comments": {
      "name": "comment.regexp",
      "begin": "\\(\\?#",
      "end": "(\\)|(?=\"))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "punctuation.comment.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.comment.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#codetags"
        }
      ]
    },
    "double-one-regexp-lookahead": {
      "begin": "(\\()\\?=",
      "end": "(\\)|(?=\"))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookahead.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookahead.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookahead.regexp punctuation.parenthesis.lookahead.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-one-regexp-expression"
        }
      ]
    },
    "double-one-regexp-lookahead-negative": {
      "begin": "(\\()\\?!",
      "end": "(\\)|(?=\"))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookahead.negative.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookahead.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookahead.negative.regexp punctuation.parenthesis.lookahead.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-one-regexp-expression"
        }
      ]
    },
    "double-one-regexp-lookbehind": {
      "begin": "(\\()\\?<=",
      "end": "(\\)|(?=\"))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookbehind.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookbehind.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookbehind.regexp punctuation.parenthesis.lookbehind.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-one-regexp-expression"
        }
      ]
    },
    "double-one-regexp-lookbehind-negative": {
      "begin": "(\\()\\?<!",
      "end": "(\\)|(?=\"))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookbehind.negative.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookbehind.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.lookbehind.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-one-regexp-expression"
        }
      ]
    },
    "double-one-regexp-conditional": {
      "begin": "(\\()\\?\\((\\w+(?:\\s+[[:alnum:]]+)?|\\d+)\\)",
      "end": "(\\)|(?=\"))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.conditional.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.conditional.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.conditional.negative.regexp punctuation.parenthesis.conditional.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-one-regexp-expression"
        }
      ]
    },
    "double-one-regexp-parentheses-non-capturing": {
      "begin": "\\(\\?:",
      "end": "(\\)|(?=\"))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-one-regexp-expression"
        }
      ]
    },
    "double-one-regexp-parentheses": {
      "begin": "\\(",
      "end": "(\\)|(?=\"))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-one-regexp-expression"
        }
      ]
    },
    "double-three-regexp-expression": {
      "patterns": [
        {
          "include": "#regexp-base-expression"
        },
        {
          "include": "#double-three-regexp-character-set"
        },
        {
          "include": "#double-three-regexp-comments"
        },
        {
          "include": "#regexp-flags"
        },
        {
          "include": "#double-three-regexp-named-group"
        },
        {
          "include": "#regexp-backreference"
        },
        {
          "include": "#double-three-regexp-lookahead"
        },
        {
          "include": "#double-three-regexp-lookahead-negative"
        },
        {
          "include": "#double-three-regexp-lookbehind"
        },
        {
          "include": "#double-three-regexp-lookbehind-negative"
        },
        {
          "include": "#double-three-regexp-conditional"
        },
        {
          "include": "#double-three-regexp-parentheses-non-capturing"
        },
        {
          "include": "#double-three-regexp-parentheses"
        },
        {
          "include": "#comments-string-double-three"
        }
      ]
    },
    "double-three-regexp-character-set": {
      "patterns": [
        {
          "match": "(?x)\n  \\[ \\^? \\] (?! .*?\\])\n"
        },
        {
          "name": "meta.character.set.regexp",
          "begin": "(\\[)(\\^)?(\\])?",
          "end": "(\\]|(?=\"\"\"))",
          "beginCaptures": {
            "1": {
              "name": "punctuation.character.set.begin.regexp constant.other.set.regexp"
            },
            "2": {
              "name": "keyword.operator.negation.regexp"
            },
            "3": {
              "name": "constant.character.set.regexp"
            }
          },
          "endCaptures": {
            "1": {
              "name": "punctuation.character.set.end.regexp constant.other.set.regexp"
            },
            "2": {
              "name": "invalid.illegal.newline.x"
            }
          },
          "patterns": [
            {
              "include": "#regexp-charecter-set-escapes"
            },
            {
              "name": "constant.character.set.regexp",
              "match": "[^\\n]"
            }
          ]
        }
      ]
    },
    "double-three-regexp-named-group": {
      "name": "meta.named.regexp",
      "begin": "(?x)\n  (\\()  (\\?P <\\w+(?:\\s+[[:alnum:]]+)?>)\n",
      "end": "(\\)|(?=\"\"\"))",
      "beginCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.named.begin.regexp"
        },
        "2": {
          "name": "entity.name.tag.named.group.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.named.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-three-regexp-expression"
        },
        {
          "include": "#comments-string-double-three"
        }
      ]
    },
    "double-three-regexp-comments": {
      "name": "comment.regexp",
      "begin": "\\(\\?#",
      "end": "(\\)|(?=\"\"\"))",
      "beginCaptures": {
        "0": {
          "name": "punctuation.comment.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.comment.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#codetags"
        }
      ]
    },
    "double-three-regexp-lookahead": {
      "begin": "(\\()\\?=",
      "end": "(\\)|(?=\"\"\"))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookahead.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookahead.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookahead.regexp punctuation.parenthesis.lookahead.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-three-regexp-expression"
        },
        {
          "include": "#comments-string-double-three"
        }
      ]
    },
    "double-three-regexp-lookahead-negative": {
      "begin": "(\\()\\?!",
      "end": "(\\)|(?=\"\"\"))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookahead.negative.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookahead.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookahead.negative.regexp punctuation.parenthesis.lookahead.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-three-regexp-expression"
        },
        {
          "include": "#comments-string-double-three"
        }
      ]
    },
    "double-three-regexp-lookbehind": {
      "begin": "(\\()\\?<=",
      "end": "(\\)|(?=\"\"\"))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookbehind.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookbehind.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookbehind.regexp punctuation.parenthesis.lookbehind.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-three-regexp-expression"
        },
        {
          "include": "#comments-string-double-three"
        }
      ]
    },
    "double-three-regexp-lookbehind-negative": {
      "begin": "(\\()\\?<!",
      "end": "(\\)|(?=\"\"\"))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookbehind.negative.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookbehind.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.lookbehind.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-three-regexp-expression"
        },
        {
          "include": "#comments-string-double-three"
        }
      ]
    },
    "double-three-regexp-conditional": {
      "begin": "(\\()\\?\\((\\w+(?:\\s+[[:alnum:]]+)?|\\d+)\\)",
      "end": "(\\)|(?=\"\"\"))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.conditional.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.conditional.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.conditional.negative.regexp punctuation.parenthesis.conditional.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-three-regexp-expression"
        },
        {
          "include": "#comments-string-double-three"
        }
      ]
    },
    "double-three-regexp-parentheses-non-capturing": {
      "begin": "\\(\\?:",
      "end": "(\\)|(?=\"\"\"))",
      "beginCaptures": {
        "0": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-three-regexp-expression"
        },
        {
          "include": "#comments-string-double-three"
        }
      ]
    },
    "double-three-regexp-parentheses": {
      "begin": "\\(",
      "end": "(\\)|(?=\"\"\"))",
      "beginCaptures": {
        "0": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-three-regexp-expression"
        },
        {
          "include": "#comments-string-double-three"
        }
      ]
    },
    "regexp-single-one-line": {
      "name": "string.regexp.quoted.single.x",
      "begin": "\\b(([uU]r)|([bB]r)|(r[bB]?))(\\')",
      "end": "(\\')|(?<!\\\\)(\\n)",
      "beginCaptures": {
        "2": {
          "name": "invalid.deprecated.prefix.x"
        },
        "3": {
          "name": "storage.type.string.x"
        },
        "4": {
          "name": "storage.type.string.x"
        },
        "5": {
          "name": "punctuation.definition.string.begin.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.x"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-one-regexp-expression"
        }
      ]
    },
    "regexp-single-three-line": {
      "name": "string.regexp.quoted.multi.x",
      "begin": "\\b(([uU]r)|([bB]r)|(r[bB]?))(\\'\\'\\')",
      "end": "(\\'\\'\\')",
      "beginCaptures": {
        "2": {
          "name": "invalid.deprecated.prefix.x"
        },
        "3": {
          "name": "storage.type.string.x"
        },
        "4": {
          "name": "storage.type.string.x"
        },
        "5": {
          "name": "punctuation.definition.string.begin.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.x"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-three-regexp-expression"
        }
      ]
    },
    "regexp-double-one-line": {
      "name": "string.regexp.quoted.single.x",
      "begin": "\\b(([uU]r)|([bB]r)|(r[bB]?))(\")",
      "end": "(\")|(?<!\\\\)(\\n)",
      "beginCaptures": {
        "2": {
          "name": "invalid.deprecated.prefix.x"
        },
        "3": {
          "name": "storage.type.string.x"
        },
        "4": {
          "name": "storage.type.string.x"
        },
        "5": {
          "name": "punctuation.definition.string.begin.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.x"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-one-regexp-expression"
        }
      ]
    },
    "regexp-double-three-line": {
      "name": "string.regexp.quoted.multi.x",
      "begin": "\\b(([uU]r)|([bB]r)|(r[bB]?))(\"\"\")",
      "end": "(\"\"\")",
      "beginCaptures": {
        "2": {
          "name": "invalid.deprecated.prefix.x"
        },
        "3": {
          "name": "storage.type.string.x"
        },
        "4": {
          "name": "storage.type.string.x"
        },
        "5": {
          "name": "punctuation.definition.string.begin.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.x"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-three-regexp-expression"
        }
      ]
    },
    "single-one-fregexp-expression": {
      "patterns": [
        {
          "include": "#fregexp-base-expression"
        },
        {
          "include": "#single-one-regexp-character-set"
        },
        {
          "include": "#single-one-regexp-comments"
        },
        {
          "include": "#regexp-flags"
        },
        {
          "include": "#single-one-regexp-named-group"
        },
        {
          "include": "#regexp-backreference"
        },
        {
          "include": "#single-one-fregexp-lookahead"
        },
        {
          "include": "#single-one-fregexp-lookahead-negative"
        },
        {
          "include": "#single-one-fregexp-lookbehind"
        },
        {
          "include": "#single-one-fregexp-lookbehind-negative"
        },
        {
          "include": "#single-one-fregexp-conditional"
        },
        {
          "include": "#single-one-fregexp-parentheses-non-capturing"
        },
        {
          "include": "#single-one-fregexp-parentheses"
        }
      ]
    },
    "single-one-fregexp-named-group": {
      "name": "meta.named.regexp",
      "begin": "(?x)\n  (\\()  (\\?P <\\w+(?:\\s+[[:alnum:]]+)?>)\n",
      "end": "(\\)|(?=\\'))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.named.begin.regexp"
        },
        "2": {
          "name": "entity.name.tag.named.group.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.named.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-one-fregexp-expression"
        }
      ]
    },
    "single-one-fregexp-lookahead": {
      "begin": "(\\()\\?=",
      "end": "(\\)|(?=\\'))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookahead.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookahead.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookahead.regexp punctuation.parenthesis.lookahead.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-one-fregexp-expression"
        }
      ]
    },
    "single-one-fregexp-lookahead-negative": {
      "begin": "(\\()\\?!",
      "end": "(\\)|(?=\\'))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookahead.negative.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookahead.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookahead.negative.regexp punctuation.parenthesis.lookahead.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-one-fregexp-expression"
        }
      ]
    },
    "single-one-fregexp-lookbehind": {
      "begin": "(\\()\\?<=",
      "end": "(\\)|(?=\\'))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookbehind.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookbehind.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookbehind.regexp punctuation.parenthesis.lookbehind.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-one-fregexp-expression"
        }
      ]
    },
    "single-one-fregexp-lookbehind-negative": {
      "begin": "(\\()\\?<!",
      "end": "(\\)|(?=\\'))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookbehind.negative.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookbehind.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.lookbehind.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-one-fregexp-expression"
        }
      ]
    },
    "single-one-fregexp-conditional": {
      "begin": "(\\()\\?\\((\\w+(?:\\s+[[:alnum:]]+)?|\\d+)\\)",
      "end": "(\\)|(?=\\'))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.conditional.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.conditional.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.conditional.negative.regexp punctuation.parenthesis.conditional.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-one-fregexp-expression"
        }
      ]
    },
    "single-one-fregexp-parentheses-non-capturing": {
      "begin": "\\(\\?:",
      "end": "(\\)|(?=\\'))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-one-fregexp-expression"
        }
      ]
    },
    "single-one-fregexp-parentheses": {
      "begin": "\\(",
      "end": "(\\)|(?=\\'))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-one-fregexp-expression"
        }
      ]
    },
    "single-three-fregexp-expression": {
      "patterns": [
        {
          "include": "#fregexp-base-expression"
        },
        {
          "include": "#single-three-regexp-character-set"
        },
        {
          "include": "#single-three-regexp-comments"
        },
        {
          "include": "#regexp-flags"
        },
        {
          "include": "#single-three-regexp-named-group"
        },
        {
          "include": "#regexp-backreference"
        },
        {
          "include": "#single-three-fregexp-lookahead"
        },
        {
          "include": "#single-three-fregexp-lookahead-negative"
        },
        {
          "include": "#single-three-fregexp-lookbehind"
        },
        {
          "include": "#single-three-fregexp-lookbehind-negative"
        },
        {
          "include": "#single-three-fregexp-conditional"
        },
        {
          "include": "#single-three-fregexp-parentheses-non-capturing"
        },
        {
          "include": "#single-three-fregexp-parentheses"
        },
        {
          "include": "#comments-string-single-three"
        }
      ]
    },
    "single-three-fregexp-named-group": {
      "name": "meta.named.regexp",
      "begin": "(?x)\n  (\\()  (\\?P <\\w+(?:\\s+[[:alnum:]]+)?>)\n",
      "end": "(\\)|(?=\\'\\'\\'))",
      "beginCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.named.begin.regexp"
        },
        "2": {
          "name": "entity.name.tag.named.group.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.named.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-three-fregexp-expression"
        },
        {
          "include": "#comments-string-single-three"
        }
      ]
    },
    "single-three-fregexp-lookahead": {
      "begin": "(\\()\\?=",
      "end": "(\\)|(?=\\'\\'\\'))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookahead.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookahead.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookahead.regexp punctuation.parenthesis.lookahead.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-three-fregexp-expression"
        },
        {
          "include": "#comments-string-single-three"
        }
      ]
    },
    "single-three-fregexp-lookahead-negative": {
      "begin": "(\\()\\?!",
      "end": "(\\)|(?=\\'\\'\\'))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookahead.negative.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookahead.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookahead.negative.regexp punctuation.parenthesis.lookahead.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-three-fregexp-expression"
        },
        {
          "include": "#comments-string-single-three"
        }
      ]
    },
    "single-three-fregexp-lookbehind": {
      "begin": "(\\()\\?<=",
      "end": "(\\)|(?=\\'\\'\\'))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookbehind.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookbehind.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookbehind.regexp punctuation.parenthesis.lookbehind.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-three-fregexp-expression"
        },
        {
          "include": "#comments-string-single-three"
        }
      ]
    },
    "single-three-fregexp-lookbehind-negative": {
      "begin": "(\\()\\?<!",
      "end": "(\\)|(?=\\'\\'\\'))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookbehind.negative.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookbehind.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.lookbehind.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-three-fregexp-expression"
        },
        {
          "include": "#comments-string-single-three"
        }
      ]
    },
    "single-three-fregexp-conditional": {
      "begin": "(\\()\\?\\((\\w+(?:\\s+[[:alnum:]]+)?|\\d+)\\)",
      "end": "(\\)|(?=\\'\\'\\'))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.conditional.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.conditional.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.conditional.negative.regexp punctuation.parenthesis.conditional.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-three-fregexp-expression"
        },
        {
          "include": "#comments-string-single-three"
        }
      ]
    },
    "single-three-fregexp-parentheses-non-capturing": {
      "begin": "\\(\\?:",
      "end": "(\\)|(?=\\'\\'\\'))",
      "beginCaptures": {
        "0": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-three-fregexp-expression"
        },
        {
          "include": "#comments-string-single-three"
        }
      ]
    },
    "single-three-fregexp-parentheses": {
      "begin": "\\(",
      "end": "(\\)|(?=\\'\\'\\'))",
      "beginCaptures": {
        "0": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-three-fregexp-expression"
        },
        {
          "include": "#comments-string-single-three"
        }
      ]
    },
    "double-one-fregexp-expression": {
      "patterns": [
        {
          "include": "#fregexp-base-expression"
        },
        {
          "include": "#double-one-regexp-character-set"
        },
        {
          "include": "#double-one-regexp-comments"
        },
        {
          "include": "#regexp-flags"
        },
        {
          "include": "#double-one-regexp-named-group"
        },
        {
          "include": "#regexp-backreference"
        },
        {
          "include": "#double-one-fregexp-lookahead"
        },
        {
          "include": "#double-one-fregexp-lookahead-negative"
        },
        {
          "include": "#double-one-fregexp-lookbehind"
        },
        {
          "include": "#double-one-fregexp-lookbehind-negative"
        },
        {
          "include": "#double-one-fregexp-conditional"
        },
        {
          "include": "#double-one-fregexp-parentheses-non-capturing"
        },
        {
          "include": "#double-one-fregexp-parentheses"
        }
      ]
    },
    "double-one-fregexp-named-group": {
      "name": "meta.named.regexp",
      "begin": "(?x)\n  (\\()  (\\?P <\\w+(?:\\s+[[:alnum:]]+)?>)\n",
      "end": "(\\)|(?=\"))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.named.begin.regexp"
        },
        "2": {
          "name": "entity.name.tag.named.group.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.named.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-one-fregexp-expression"
        }
      ]
    },
    "double-one-fregexp-lookahead": {
      "begin": "(\\()\\?=",
      "end": "(\\)|(?=\"))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookahead.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookahead.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookahead.regexp punctuation.parenthesis.lookahead.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-one-fregexp-expression"
        }
      ]
    },
    "double-one-fregexp-lookahead-negative": {
      "begin": "(\\()\\?!",
      "end": "(\\)|(?=\"))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookahead.negative.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookahead.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookahead.negative.regexp punctuation.parenthesis.lookahead.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-one-fregexp-expression"
        }
      ]
    },
    "double-one-fregexp-lookbehind": {
      "begin": "(\\()\\?<=",
      "end": "(\\)|(?=\"))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookbehind.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookbehind.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookbehind.regexp punctuation.parenthesis.lookbehind.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-one-fregexp-expression"
        }
      ]
    },
    "double-one-fregexp-lookbehind-negative": {
      "begin": "(\\()\\?<!",
      "end": "(\\)|(?=\"))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookbehind.negative.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookbehind.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.lookbehind.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-one-fregexp-expression"
        }
      ]
    },
    "double-one-fregexp-conditional": {
      "begin": "(\\()\\?\\((\\w+(?:\\s+[[:alnum:]]+)?|\\d+)\\)",
      "end": "(\\)|(?=\"))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.conditional.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.conditional.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.conditional.negative.regexp punctuation.parenthesis.conditional.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-one-fregexp-expression"
        }
      ]
    },
    "double-one-fregexp-parentheses-non-capturing": {
      "begin": "\\(\\?:",
      "end": "(\\)|(?=\"))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-one-fregexp-expression"
        }
      ]
    },
    "double-one-fregexp-parentheses": {
      "begin": "\\(",
      "end": "(\\)|(?=\"))|((?=(?<!\\\\)\\n))",
      "beginCaptures": {
        "0": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-one-fregexp-expression"
        }
      ]
    },
    "double-three-fregexp-expression": {
      "patterns": [
        {
          "include": "#fregexp-base-expression"
        },
        {
          "include": "#double-three-regexp-character-set"
        },
        {
          "include": "#double-three-regexp-comments"
        },
        {
          "include": "#regexp-flags"
        },
        {
          "include": "#double-three-regexp-named-group"
        },
        {
          "include": "#regexp-backreference"
        },
        {
          "include": "#double-three-fregexp-lookahead"
        },
        {
          "include": "#double-three-fregexp-lookahead-negative"
        },
        {
          "include": "#double-three-fregexp-lookbehind"
        },
        {
          "include": "#double-three-fregexp-lookbehind-negative"
        },
        {
          "include": "#double-three-fregexp-conditional"
        },
        {
          "include": "#double-three-fregexp-parentheses-non-capturing"
        },
        {
          "include": "#double-three-fregexp-parentheses"
        },
        {
          "include": "#comments-string-double-three"
        }
      ]
    },
    "double-three-fregexp-named-group": {
      "name": "meta.named.regexp",
      "begin": "(?x)\n  (\\()  (\\?P <\\w+(?:\\s+[[:alnum:]]+)?>)\n",
      "end": "(\\)|(?=\"\"\"))",
      "beginCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.named.begin.regexp"
        },
        "2": {
          "name": "entity.name.tag.named.group.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.named.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-three-fregexp-expression"
        },
        {
          "include": "#comments-string-double-three"
        }
      ]
    },
    "double-three-fregexp-lookahead": {
      "begin": "(\\()\\?=",
      "end": "(\\)|(?=\"\"\"))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookahead.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookahead.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookahead.regexp punctuation.parenthesis.lookahead.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-three-fregexp-expression"
        },
        {
          "include": "#comments-string-double-three"
        }
      ]
    },
    "double-three-fregexp-lookahead-negative": {
      "begin": "(\\()\\?!",
      "end": "(\\)|(?=\"\"\"))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookahead.negative.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookahead.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookahead.negative.regexp punctuation.parenthesis.lookahead.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-three-fregexp-expression"
        },
        {
          "include": "#comments-string-double-three"
        }
      ]
    },
    "double-three-fregexp-lookbehind": {
      "begin": "(\\()\\?<=",
      "end": "(\\)|(?=\"\"\"))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookbehind.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookbehind.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookbehind.regexp punctuation.parenthesis.lookbehind.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-three-fregexp-expression"
        },
        {
          "include": "#comments-string-double-three"
        }
      ]
    },
    "double-three-fregexp-lookbehind-negative": {
      "begin": "(\\()\\?<!",
      "end": "(\\)|(?=\"\"\"))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.lookbehind.negative.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.lookbehind.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.lookbehind.negative.regexp punctuation.parenthesis.lookbehind.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-three-fregexp-expression"
        },
        {
          "include": "#comments-string-double-three"
        }
      ]
    },
    "double-three-fregexp-conditional": {
      "begin": "(\\()\\?\\((\\w+(?:\\s+[[:alnum:]]+)?|\\d+)\\)",
      "end": "(\\)|(?=\"\"\"))",
      "beginCaptures": {
        "0": {
          "name": "keyword.operator.conditional.regexp"
        },
        "1": {
          "name": "punctuation.parenthesis.conditional.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "keyword.operator.conditional.negative.regexp punctuation.parenthesis.conditional.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-three-fregexp-expression"
        },
        {
          "include": "#comments-string-double-three"
        }
      ]
    },
    "double-three-fregexp-parentheses-non-capturing": {
      "begin": "\\(\\?:",
      "end": "(\\)|(?=\"\"\"))",
      "beginCaptures": {
        "0": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.non-capturing.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-three-fregexp-expression"
        },
        {
          "include": "#comments-string-double-three"
        }
      ]
    },
    "double-three-fregexp-parentheses": {
      "begin": "\\(",
      "end": "(\\)|(?=\"\"\"))",
      "beginCaptures": {
        "0": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.begin.regexp"
        }
      },
      "endCaptures": {
        "1": {
          "name": "support.other.parenthesis.regexp punctuation.parenthesis.end.regexp"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-three-fregexp-expression"
        },
        {
          "include": "#comments-string-double-three"
        }
      ]
    },
    "fregexp-single-one-line": {
      "name": "string.interpolated.x string.regexp.quoted.single.x",
      "begin": "\\b(([uU]r)|([fF]r)|(r[fF]?))(\\')",
      "end": "(\\')|(?<!\\\\)(\\n)",
      "beginCaptures": {
        "2": {
          "name": "invalid.deprecated.prefix.x"
        },
        "3": {
          "name": "storage.type.string.x"
        },
        "4": {
          "name": "storage.type.string.x"
        },
        "5": {
          "name": "punctuation.definition.string.begin.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.x"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-one-fregexp-expression"
        }
      ]
    },
    "fregexp-single-three-line": {
      "name": "string.interpolated.x string.regexp.quoted.multi.x",
      "begin": "\\b(([uU]r)|([fF]r)|(r[fF]?))(\\'\\'\\')",
      "end": "(\\'\\'\\')",
      "beginCaptures": {
        "2": {
          "name": "invalid.deprecated.prefix.x"
        },
        "3": {
          "name": "storage.type.string.x"
        },
        "4": {
          "name": "storage.type.string.x"
        },
        "5": {
          "name": "punctuation.definition.string.begin.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.x"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#single-three-fregexp-expression"
        }
      ]
    },
    "fregexp-double-one-line": {
      "name": "string.interpolated.x string.regexp.quoted.single.x",
      "begin": "\\b(([uU]r)|([fF]r)|(r[fF]?))(\")",
      "end": "(\")|(?<!\\\\)(\\n)",
      "beginCaptures": {
        "2": {
          "name": "invalid.deprecated.prefix.x"
        },
        "3": {
          "name": "storage.type.string.x"
        },
        "4": {
          "name": "storage.type.string.x"
        },
        "5": {
          "name": "punctuation.definition.string.begin.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.x"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-one-fregexp-expression"
        }
      ]
    },
    "fregexp-double-three-line": {
      "name": "string.interpolated.x string.regexp.quoted.multi.x",
      "begin": "\\b(([uU]r)|([fF]r)|(r[fF]?))(\"\"\")",
      "end": "(\"\"\")",
      "beginCaptures": {
        "2": {
          "name": "invalid.deprecated.prefix.x"
        },
        "3": {
          "name": "storage.type.string.x"
        },
        "4": {
          "name": "storage.type.string.x"
        },
        "5": {
          "name": "punctuation.definition.string.begin.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.x"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#double-three-fregexp-expression"
        }
      ]
    },
    "string-raw-quoted-single-line": {
      "name": "string.quoted.raw.single.x",
      "begin": "\\b(([uU]R)|(R))((['\"]))",
      "end": "(\\4)|((?<!\\\\)\\n)",
      "beginCaptures": {
        "2": {
          "name": "invalid.deprecated.prefix.x"
        },
        "3": {
          "name": "storage.type.string.x"
        },
        "4": {
          "name": "punctuation.definition.string.begin.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.x"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#string-single-bad-brace1-formatting-raw"
        },
        {
          "include": "#string-single-bad-brace2-formatting-raw"
        },
        {
          "include": "#string-raw-guts"
        }
      ]
    },
    "string-bin-quoted-single-line": {
      "name": "string.quoted.binary.single.x",
      "begin": "(\\b[bB])((['\"]))",
      "end": "(\\2)|((?<!\\\\)\\n)",
      "beginCaptures": {
        "1": {
          "name": "storage.type.string.x"
        },
        "2": {
          "name": "punctuation.definition.string.begin.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.x"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#string-entity"
        }
      ]
    },
    "string-raw-bin-quoted-single-line": {
      "name": "string.quoted.raw.binary.single.x",
      "begin": "(\\b(?:R[bB]|[bB]R))((['\"]))",
      "end": "(\\2)|((?<!\\\\)\\n)",
      "beginCaptures": {
        "1": {
          "name": "storage.type.string.x"
        },
        "2": {
          "name": "punctuation.definition.string.begin.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.x"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#string-raw-bin-guts"
        }
      ]
    },
    "string-quoted-single-line": {
      "name": "string.quoted.single.x",
      "begin": "(?:\\b([rR])(?=[uU]))?([uU])?((['\"]))",
      "end": "(\\3)|((?<!\\\\)\\n)",
      "beginCaptures": {
        "1": {
          "name": "invalid.illegal.prefix.x"
        },
        "2": {
          "name": "storage.type.string.x"
        },
        "3": {
          "name": "punctuation.definition.string.begin.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.x"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#string-single-bad-brace1-formatting-unicode"
        },
        {
          "include": "#string-single-bad-brace2-formatting-unicode"
        },
        {
          "include": "#string-unicode-guts"
        }
      ]
    },
    "string-single-bad-brace1-formatting-unicode": {
      "comment": "template using {% ... %}",
      "begin": "(?x)\n    (?= \\{%\n          ( .*? (?!(['\"])|((?<!\\\\)\\n)) )\n        %\\}\n    )\n",
      "end": "(?=(['\"])|((?<!\\\\)\\n))",
      "patterns": [
        {
          "include": "#escape-sequence-unicode"
        },
        {
          "include": "#escape-sequence"
        },
        {
          "include": "#string-line-continuation"
        }
      ]
    },
    "string-single-bad-brace1-formatting-raw": {
      "comment": "template using {% ... %}",
      "begin": "(?x)\n    (?= \\{%\n          ( .*? (?!(['\"])|((?<!\\\\)\\n)) )\n        %\\}\n    )\n",
      "end": "(?=(['\"])|((?<!\\\\)\\n))",
      "patterns": [
        {
          "include": "#string-consume-escape"
        }
      ]
    },
    "string-single-bad-brace2-formatting-unicode": {
      "comment": "odd format or format-like syntax",
      "begin": "(?x)\n    (?!\\{\\{)\n    (?= \\{ (\n              \\w*? (?!(['\"])|((?<!\\\\)\\n)) [^!:\\.\\[}\\w]\n           )\n        .*?(?!(['\"])|((?<!\\\\)\\n))\n        \\}\n    )\n",
      "end": "(?=(['\"])|((?<!\\\\)\\n))",
      "patterns": [
        {
          "include": "#escape-sequence-unicode"
        },
        {
          "include": "#string-entity"
        }
      ]
    },
    "string-single-bad-brace2-formatting-raw": {
      "comment": "odd format or format-like syntax",
      "begin": "(?x)\n    (?!\\{\\{)\n    (?= \\{ (\n              \\w*? (?!(['\"])|((?<!\\\\)\\n)) [^!:\\.\\[}\\w]\n           )\n        .*?(?!(['\"])|((?<!\\\\)\\n))\n        \\}\n    )\n",
      "end": "(?=(['\"])|((?<!\\\\)\\n))",
      "patterns": [
        {
          "include": "#string-consume-escape"
        },
        {
          "include": "#string-formatting"
        }
      ]
    },
    "string-raw-quoted-multi-line": {
      "name": "string.quoted.raw.multi.x",
      "begin": "\\b(([uU]R)|(R))('''|\"\"\")",
      "end": "(\\4)",
      "beginCaptures": {
        "2": {
          "name": "invalid.deprecated.prefix.x"
        },
        "3": {
          "name": "storage.type.string.x"
        },
        "4": {
          "name": "punctuation.definition.string.begin.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.x"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#string-multi-bad-brace1-formatting-raw"
        },
        {
          "include": "#string-multi-bad-brace2-formatting-raw"
        },
        {
          "include": "#string-raw-guts"
        }
      ]
    },
    "string-bin-quoted-multi-line": {
      "name": "string.quoted.binary.multi.x",
      "begin": "(\\b[bB])('''|\"\"\")",
      "end": "(\\2)",
      "beginCaptures": {
        "1": {
          "name": "storage.type.string.x"
        },
        "2": {
          "name": "punctuation.definition.string.begin.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.x"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#string-entity"
        }
      ]
    },
    "string-raw-bin-quoted-multi-line": {
      "name": "string.quoted.raw.binary.multi.x",
      "begin": "(\\b(?:R[bB]|[bB]R))('''|\"\"\")",
      "end": "(\\2)",
      "beginCaptures": {
        "1": {
          "name": "storage.type.string.x"
        },
        "2": {
          "name": "punctuation.definition.string.begin.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.x"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#string-raw-bin-guts"
        }
      ]
    },
    "string-quoted-multi-line": {
      "name": "string.quoted.multi.x",
      "begin": "(?:\\b([rR])(?=[uU]))?([uU])?('''|\"\"\")",
      "end": "(\\3)",
      "beginCaptures": {
        "1": {
          "name": "invalid.illegal.prefix.x"
        },
        "2": {
          "name": "storage.type.string.x"
        },
        "3": {
          "name": "punctuation.definition.string.begin.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.x"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#string-multi-bad-brace1-formatting-unicode"
        },
        {
          "include": "#string-multi-bad-brace2-formatting-unicode"
        },
        {
          "include": "#string-unicode-guts"
        }
      ]
    },
    "string-multi-bad-brace1-formatting-unicode": {
      "comment": "template using {% ... %}",
      "begin": "(?x)\n    (?= \\{%\n          ( .*? (?!'''|\"\"\") )\n        %\\}\n    )\n",
      "end": "(?='''|\"\"\")",
      "patterns": [
        {
          "include": "#escape-sequence-unicode"
        },
        {
          "include": "#escape-sequence"
        },
        {
          "include": "#string-line-continuation"
        }
      ]
    },
    "string-multi-bad-brace1-formatting-raw": {
      "comment": "template using {% ... %}",
      "begin": "(?x)\n    (?= \\{%\n          ( .*? (?!'''|\"\"\") )\n        %\\}\n    )\n",
      "end": "(?='''|\"\"\")",
      "patterns": [
        {
          "include": "#string-consume-escape"
        }
      ]
    },
    "string-multi-bad-brace2-formatting-unicode": {
      "comment": "odd format or format-like syntax",
      "begin": "(?x)\n    (?!\\{\\{)\n    (?= \\{ (\n              \\w*? (?!'''|\"\"\") [^!:\\.\\[}\\w]\n           )\n        .*?(?!'''|\"\"\")\n        \\}\n    )\n",
      "end": "(?='''|\"\"\")",
      "patterns": [
        {
          "include": "#escape-sequence-unicode"
        },
        {
          "include": "#string-entity"
        }
      ]
    },
    "string-multi-bad-brace2-formatting-raw": {
      "comment": "odd format or format-like syntax",
      "begin": "(?x)\n    (?!\\{\\{)\n    (?= \\{ (\n              \\w*? (?!'''|\"\"\") [^!:\\.\\[}\\w]\n           )\n        .*?(?!'''|\"\"\")\n        \\}\n    )\n",
      "end": "(?='''|\"\"\")",
      "patterns": [
        {
          "include": "#string-consume-escape"
        },
        {
          "include": "#string-formatting"
        }
      ]
    },
    "fstring-fnorm-quoted-single-line": {
      "name": "meta.fstring.x",
      "begin": "(\\b[fF])([bBuU])?((['\"]))",
      "end": "(\\3)|((?<!\\\\)\\n)",
      "beginCaptures": {
        "1": {
          "name": "string.interpolated.x string.quoted.single.x storage.type.string.x"
        },
        "2": {
          "name": "invalid.illegal.prefix.x"
        },
        "3": {
          "name": "punctuation.definition.string.begin.x string.interpolated.x string.quoted.single.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.x string.interpolated.x string.quoted.single.x"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#fstring-guts"
        },
        {
          "include": "#fstring-illegal-single-brace"
        },
        {
          "include": "#fstring-single-brace"
        },
        {
          "include": "#fstring-single-core"
        }
      ]
    },
    "fstring-normf-quoted-single-line": {
      "name": "meta.fstring.x",
      "begin": "(\\b[bBuU])([fF])((['\"]))",
      "end": "(\\3)|((?<!\\\\)\\n)",
      "beginCaptures": {
        "1": {
          "name": "invalid.illegal.prefix.x"
        },
        "2": {
          "name": "string.interpolated.x string.quoted.single.x storage.type.string.x"
        },
        "3": {
          "name": "punctuation.definition.string.begin.x string.quoted.single.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.x string.interpolated.x string.quoted.single.x"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#fstring-guts"
        },
        {
          "include": "#fstring-illegal-single-brace"
        },
        {
          "include": "#fstring-single-brace"
        },
        {
          "include": "#fstring-single-core"
        }
      ]
    },
    "fstring-raw-quoted-single-line": {
      "name": "meta.fstring.x",
      "begin": "(\\b(?:[R][fF]|[fF][R]))((['\"]))",
      "end": "(\\2)|((?<!\\\\)\\n)",
      "beginCaptures": {
        "1": {
          "name": "string.interpolated.x string.quoted.raw.single.x storage.type.string.x"
        },
        "2": {
          "name": "punctuation.definition.string.begin.x string.quoted.raw.single.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.x string.interpolated.x string.quoted.raw.single.x"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#fstring-raw-guts"
        },
        {
          "include": "#fstring-illegal-single-brace"
        },
        {
          "include": "#fstring-single-brace"
        },
        {
          "include": "#fstring-raw-single-core"
        }
      ]
    },
    "fstring-single-core": {
      "name": "string.interpolated.x string.quoted.single.x",
      "match": "(?x)\n  (.+?)\n    (\n      (?# .* and .*? in multi-line match need special handling of\n        newlines otherwise SublimeText and Atom will match slightly\n        differently.\n\n        The guard for newlines has to be separate from the\n        lookahead because of special $ matching rule.)\n      ($\\n?)\n      |\n      (?=[\\\\\\}\\{]|(['\"])|((?<!\\\\)\\n))\n    )\n  (?# due to how multiline regexps are matched we need a special case\n    for matching a newline character)\n  | \\n\n"
    },
    "fstring-raw-single-core": {
      "name": "string.interpolated.x string.quoted.raw.single.x",
      "match": "(?x)\n  (.+?)\n    (\n      (?# .* and .*? in multi-line match need special handling of\n        newlines otherwise SublimeText and Atom will match slightly\n        differently.\n\n        The guard for newlines has to be separate from the\n        lookahead because of special $ matching rule.)\n      ($\\n?)\n      |\n      (?=[\\\\\\}\\{]|(['\"])|((?<!\\\\)\\n))\n    )\n  (?# due to how multiline regexps are matched we need a special case\n    for matching a newline character)\n  | \\n\n"
    },
    "fstring-single-brace": {
      "comment": "value interpolation using { ... }",
      "begin": "(\\{)",
      "end": "(?x)\n  (\\})|(?=\\n)\n",
      "beginCaptures": {
        "1": {
          "name": "constant.character.format.placeholder.other.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "constant.character.format.placeholder.other.x"
        }
      },
      "patterns": [
        {
          "include": "#fstring-terminator-single"
        },
        {
          "include": "#f-expression"
        }
      ]
    },
    "fstring-terminator-single": {
      "patterns": [
        {
          "name": "storage.type.format.x",
          "match": "(![rsa])(?=})"
        },
        {
          "match": "(?x)\n  (![rsa])?\n    ( : \\w? [<>=^]? [-+ ]? \\#?\n      \\d* ,? (\\.\\d+)? [bcdeEfFgGnosxX%]? )(?=})\n",
          "captures": {
            "1": {
              "name": "storage.type.format.x"
            },
            "2": {
              "name": "storage.type.format.x"
            }
          }
        },
        {
          "include": "#fstring-terminator-single-tail"
        }
      ]
    },
    "fstring-terminator-single-tail": {
      "begin": "(![rsa])?(:)(?=.*?{)",
      "end": "(?=})|(?=\\n)",
      "beginCaptures": {
        "1": {
          "name": "storage.type.format.x"
        },
        "2": {
          "name": "storage.type.format.x"
        }
      },
      "patterns": [
        {
          "include": "#fstring-illegal-single-brace"
        },
        {
          "include": "#fstring-single-brace"
        },
        {
          "name": "storage.type.format.x",
          "match": "([bcdeEfFgGnosxX%])(?=})"
        },
        {
          "name": "storage.type.format.x",
          "match": "(\\.\\d+)"
        },
        {
          "name": "storage.type.format.x",
          "match": "(,)"
        },
        {
          "name": "storage.type.format.x",
          "match": "(\\d+)"
        },
        {
          "name": "storage.type.format.x",
          "match": "(\\#)"
        },
        {
          "name": "storage.type.format.x",
          "match": "([-+ ])"
        },
        {
          "name": "storage.type.format.x",
          "match": "([<>=^])"
        },
        {
          "name": "storage.type.format.x",
          "match": "(\\w)"
        }
      ]
    },
    "fstring-fnorm-quoted-multi-line": {
      "name": "meta.fstring.x",
      "begin": "(\\b[fF])([bBuU])?('''|\"\"\")",
      "end": "(\\3)",
      "beginCaptures": {
        "1": {
          "name": "string.interpolated.x string.quoted.multi.x storage.type.string.x"
        },
        "2": {
          "name": "invalid.illegal.prefix.x"
        },
        "3": {
          "name": "punctuation.definition.string.begin.x string.interpolated.x string.quoted.multi.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.x string.interpolated.x string.quoted.multi.x"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#fstring-guts"
        },
        {
          "include": "#fstring-illegal-multi-brace"
        },
        {
          "include": "#fstring-multi-brace"
        },
        {
          "include": "#fstring-multi-core"
        }
      ]
    },
    "fstring-normf-quoted-multi-line": {
      "name": "meta.fstring.x",
      "begin": "(\\b[bBuU])([fF])('''|\"\"\")",
      "end": "(\\3)",
      "beginCaptures": {
        "1": {
          "name": "invalid.illegal.prefix.x"
        },
        "2": {
          "name": "string.interpolated.x string.quoted.multi.x storage.type.string.x"
        },
        "3": {
          "name": "punctuation.definition.string.begin.x string.quoted.multi.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.x string.interpolated.x string.quoted.multi.x"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#fstring-guts"
        },
        {
          "include": "#fstring-illegal-multi-brace"
        },
        {
          "include": "#fstring-multi-brace"
        },
        {
          "include": "#fstring-multi-core"
        }
      ]
    },
    "fstring-raw-quoted-multi-line": {
      "name": "meta.fstring.x",
      "begin": "(\\b(?:[R][fF]|[fF][R]))('''|\"\"\")",
      "end": "(\\2)",
      "beginCaptures": {
        "1": {
          "name": "string.interpolated.x string.quoted.raw.multi.x storage.type.string.x"
        },
        "2": {
          "name": "punctuation.definition.string.begin.x string.quoted.raw.multi.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "punctuation.definition.string.end.x string.interpolated.x string.quoted.raw.multi.x"
        },
        "2": {
          "name": "invalid.illegal.newline.x"
        }
      },
      "patterns": [
        {
          "include": "#fstring-raw-guts"
        },
        {
          "include": "#fstring-illegal-multi-brace"
        },
        {
          "include": "#fstring-multi-brace"
        },
        {
          "include": "#fstring-raw-multi-core"
        }
      ]
    },
    "fstring-multi-core": {
      "name": "string.interpolated.x string.quoted.multi.x",
      "match": "(?x)\n  (.+?)\n    (\n      (?# .* and .*? in multi-line match need special handling of\n        newlines otherwise SublimeText and Atom will match slightly\n        differently.\n\n        The guard for newlines has to be separate from the\n        lookahead because of special $ matching rule.)\n      ($\\n?)\n      |\n      (?=[\\\\\\}\\{]|'''|\"\"\")\n    )\n  (?# due to how multiline regexps are matched we need a special case\n    for matching a newline character)\n  | \\n\n"
    },
    "fstring-raw-multi-core": {
      "name": "string.interpolated.x string.quoted.raw.multi.x",
      "match": "(?x)\n  (.+?)\n    (\n      (?# .* and .*? in multi-line match need special handling of\n        newlines otherwise SublimeText and Atom will match slightly\n        differently.\n\n        The guard for newlines has to be separate from the\n        lookahead because of special $ matching rule.)\n      ($\\n?)\n      |\n      (?=[\\\\\\}\\{]|'''|\"\"\")\n    )\n  (?# due to how multiline regexps are matched we need a special case\n    for matching a newline character)\n  | \\n\n"
    },
    "fstring-multi-brace": {
      "comment": "value interpolation using { ... }",
      "begin": "(\\{)",
      "end": "(?x)\n  (\\})\n",
      "beginCaptures": {
        "1": {
          "name": "constant.character.format.placeholder.other.x"
        }
      },
      "endCaptures": {
        "1": {
          "name": "constant.character.format.placeholder.other.x"
        }
      },
      "patterns": [
        {
          "include": "#fstring-terminator-multi"
        },
        {
          "include": "#f-expression"
        }
      ]
    },
    "fstring-terminator-multi": {
      "patterns": [
        {
          "name": "storage.type.format.x",
          "match": "(![rsa])(?=})"
        },
        {
          "match": "(?x)\n  (![rsa])?\n    ( : \\w? [<>=^]? [-+ ]? \\#?\n      \\d* ,? (\\.\\d+)? [bcdeEfFgGnosxX%]? )(?=})\n",
          "captures": {
            "1": {
              "name": "storage.type.format.x"
            },
            "2": {
              "name": "storage.type.format.x"
            }
          }
        },
        {
          "include": "#fstring-terminator-multi-tail"
        }
      ]
    },
    "fstring-terminator-multi-tail": {
      "begin": "(![rsa])?(:)(?=.*?{)",
      "end": "(?=})",
      "beginCaptures": {
        "1": {
          "name": "storage.type.format.x"
        },
        "2": {
          "name": "storage.type.format.x"
        }
      },
      "patterns": [
        {
          "include": "#fstring-illegal-multi-brace"
        },
        {
          "include": "#fstring-multi-brace"
        },
        {
          "name": "storage.type.format.x",
          "match": "([bcdeEfFgGnosxX%])(?=})"
        },
        {
          "name": "storage.type.format.x",
          "match": "(\\.\\d+)"
        },
        {
          "name": "storage.type.format.x",
          "match": "(,)"
        },
        {
          "name": "storage.type.format.x",
          "match": "(\\d+)"
        },
        {
          "name": "storage.type.format.x",
          "match": "(\\#)"
        },
        {
          "name": "storage.type.format.x",
          "match": "([-+ ])"
        },
        {
          "name": "storage.type.format.x",
          "match": "([<>=^])"
        },
        {
          "name": "storage.type.format.x",
          "match": "(\\w)"
        }
      ]
    }
  }
}